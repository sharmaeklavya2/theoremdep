{
"fields": [
"title",
"description",
"keywords"
],
"corpus": [
{
"type": "def",
"title": "Bin packing and Knapsack",
"description": "In the bin packing problem, we are given a set of items and an infinite supply of identical bins. Our task is to pack the items into the minimum number of bins. In the knapsack problem, we are given a set of items, and each item has a non-negative profit associated with it. Our task is to pack a maximum-profit subset of the items into a single bin.",
"uci": "/packing/bp-and-ks",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/bp-and-ks.html"
},
{
"type": "theorem",
"title": "1BP: \u2308size(I)\u2309 \u2264 opt(I)",
"uci": "/packing/1d/size-le-opt",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/size-le-opt.html"
},
{
"type": "theorem",
"title": "1BP: NextFit(I) \u2264 \u2308size(I)/(1-\u03b5)\u2309 for \u03b5-small items",
"description": "The number of bins used by the Next-Fit algorithm to pack a set I of items is at most \u2308size(I)/(1-\u03b5)\u2309 when each item has size \u2264 \u03b5",
"uci": "/packing/1d/next-fit-small",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/next-fit-small.html"
},
{
"type": "theorem",
"title": "1BP: NextFit(S) \u2264 \u23082size(S)\u2309",
"description": "The number of bins used by the Next-Fit algorithm to pack a set S of items is at most \u23082size(S)\u2309. This gives us a 2-approx algorithm for 1BP.",
"uci": "/packing/1d/next-fit",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/next-fit.html"
},
{
"type": "theorem",
"title": "Pseudo-polynomial time algorithm for 1D knapsack",
"description": "Pseudo-polynomial time exact algorithm for knapsack using dynamic programming.",
"uci": "/packing/1d/ks-dp-algo",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/ks-dp-algo.html"
},
{
"type": "theorem",
"title": "FPTAS for 1D knapsack",
"description": "FPTAS for knapsack which rounds down profits and uses the exact DP algorithm as subroutine.",
"uci": "/packing/1d/ks-fptas",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/ks-fptas.html"
},
{
"type": "theorem",
"title": "1BP: extending by small items",
"description": "Packing of items of size > \u03b5 into m bins can be extended to a packing for the entire input with at most max(l, size(I)/(1-\u03b5)+1) bins.",
"uci": "/packing/1d/extend-by-small",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/extend-by-small.html"
},
{
"type": "def",
"title": "Geometric packing problems (BP, KS, SP) and rvol",
"description": "Definitions of geometric bin packing, geometric knapsack, strip packing (SP), vol and rvol.",
"uci": "/packing/geometric/bp-ks-sp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/bp-ks-sp.html"
},
{
"type": "def",
"title": "NFDH algorithm",
"description": "Next-Fit Decreasing Height (NFDH) is an algorithm for 2D geometric bin packing and 2D strip packing. It sorts items by height in descending order and packs them into shelves.",
"uci": "/packing/geometric/nfdh/algo",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/algo.html"
},
{
"type": "theorem",
"title": "NFDH: area of adjacent bins",
"description": "In the output of NFDH, for any pair of adjacent bins except the last, one of the bins has total rvol more than 1/4.",
"uci": "/packing/geometric/nfdh/bp-adj",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/bp-adj.html"
},
{
"type": "theorem",
"title": "2D SP: NFDH(I) < a(I)/(W-\u03b5) + hmax for \u03b5-small items",
"uci": "/packing/geometric/nfdh/sp-small",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/sp-small.html"
},
{
"type": "theorem",
"title": "2D SP: NFDH(I) < 2rvol(I) + hmax",
"description": "NFDH is an asymptotic 2-approx algorithm for 2D strip packing.",
"uci": "/packing/geometric/nfdh/sp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/sp.html"
},
{
"type": "theorem",
"title": "2D BP: NFDH(I) \u2264 4\u2308rvol(I)\u2309 + 1",
"description": "NFDH is an asymptotic 4-approx algorithm for 2D geometric bin packing.",
"uci": "/packing/geometric/nfdh/bp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/bp.html"
},
{
"type": "theorem",
"title": "2D BP: NFDH for items of small height",
"uci": "/packing/geometric/nfdh/bp-wide",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/bp-wide.html"
},
{
"type": "theorem",
"title": "2D BP: NFDH for small items",
"uci": "/packing/geometric/nfdh/bp-small",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/bp-small.html"
},
{
"type": "theorem",
"title": "2D BP: NFDH for items of small width",
"uci": "/packing/geometric/nfdh/bp-tall",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/nfdh/bp-tall.html"
},
{
"type": "theorem",
"title": "PTAS for 2D geometric density-restricted knapsack",
"description": "When the profit-to-area ratio is upper-bounded and lower-bounded by a constant, then there is a PTAS for the knapsack problem.",
"uci": "/packing/geometric/2d-dr-ks-ptas",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/2d-dr-ks-ptas.html"
},
{
"type": "def",
"title": "Bin packing: configuration LP",
"description": "Representation of the bin packing problem as an integer linear program. Each variable corresponds to a configuration, which is a feasible packing of a subset of items in 1 bin.",
"uci": "/packing/config-lp/config-lp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/config-lp.html"
},
{
"type": "theorem",
"title": "1BP: size(I) \u2264 lin(I)",
"uci": "/packing/config-lp/size-lb",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/size-lb.html"
},
{
"type": "def",
"title": "Bin packing: density-restricted config LP",
"uci": "/packing/config-lp/dr-config-lp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/dr-config-lp.html"
},
{
"type": "theorem",
"title": "Bin packing: config LP is not affected by grouping identical items",
"uci": "/packing/config-lp/identical",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/identical.html"
},
{
"type": "theorem",
"title": "Bin packing: removing density restriction from config LP",
"description": "Assuming the presence of a suitable primitive bin packing algorithm, we can solve the config LP almost optimally by solving the density-restricted config LP almost optimally.",
"uci": "/packing/config-lp/density-unrestr",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/density-unrestr.html"
},
{
"type": "def",
"title": "Bin packing: union of input instances",
"description": "The union of I and J, denoted as I+J, is the input instance which contains items from both I and J (with duplication).",
"uci": "/packing/union",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/union.html"
},
{
"type": "def",
"title": "Bin packing: predecessor of an input instance",
"description": "Input instance I is said to be a predecessor of input instance J iff each item in I has a corresponding item in J which is at least as large in every dimension.",
"uci": "/packing/predecessor",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/predecessor.html"
},
{
"type": "theoremdef",
"title": "1BP: linear grouping",
"description": "Linear grouping is a transformation on an input instance that gives us a predecessor and a successor.",
"uci": "/packing/1d/linear-grouping",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/linear-grouping.html"
},
{
"type": "theorem",
"title": "Bin packing: config LP of predecessor",
"description": "Let I be the predecessor of J. Then lin(I) \u2264 lin(J).",
"uci": "/packing/config-lp/prec",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/prec.html"
},
{
"type": "def",
"title": "\u03c3-algebra",
"description": "Let F be a subset of the power-set of X. F is said to be a \u03c3-algebra over X iff F satisfies certain axioms.",
"uci": "/measure-theory/sigma-algebra",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/measure-theory/sigma-algebra.html"
},
{
"type": "theoremdef",
"title": "Generated \u03c3-algebra",
"description": "Let F be a subset of the power-set of X. Define \u03c3(F) as the set containing all the subsets of X that can be made from elements of F by a countable number of complement, union and intersection operations. Then \u03c3(F) is a \u03c3-algebra.",
"uci": "/measure-theory/generated-sigma-algebra",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/measure-theory/generated-sigma-algebra.html"
},
{
"type": "def",
"title": "Borel algebra",
"description": "Let T be a topological space. Then the Borel algebra B(T) is the \u03c3-algebra generated by all open sets in T.",
"uci": "/measure-theory/borel-algebra",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/measure-theory/borel-algebra.html"
},
{
"type": "def",
"title": "Measurable function",
"description": "A function from \u03c3-algebra (X1, F1) to \u03c3-algebra (X2, F2) is measurable iff each preimage of f is in F1.",
"uci": "/measure-theory/measurable-func",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/measure-theory/measurable-func.html"
},
{
"type": "theorem",
"title": "Generators of the real Borel algebra",
"description": "Let F be the set of all open sets of \u211d of the form (-\u221e, a). Then B(\u211d) = \u03c3(F).",
"uci": "/measure-theory/real-borel-algebra-generators",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/measure-theory/real-borel-algebra-generators.html",
"status": "incomplete"
},
{
"type": "def",
"title": "Measure",
"description": "A measure on a set is a systematic way to assign a number to each suitable subset of that set, intuitively interpreted as its size.",
"uci": "/measure-theory/measure",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/measure-theory/measure.html"
},
{
"type": "theorem",
"title": "\u03c3-algebra is closed under countable intersections",
"description": "Let (X, F) be a \u03c3-algebra. Then the intersection of a countable number of sets from F lies in F.",
"uci": "/measure-theory/sigma-algebra-closed-under-intersection",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/measure-theory/sigma-algebra-closed-under-intersection.html"
},
{
"type": "def",
"title": "Graph",
"description": "A graph G(V, E) is a pair of vertices V and a relation E from V to V.",
"keywords": [
"graph",
"multigraph",
"vertices",
"edges",
"adjacent",
"loop",
"simple graph",
"subgraph",
"source",
"destination"
],
"uci": "/graph-theory/graph",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/graph.html"
},
{
"type": "def",
"title": "Cut in a graph",
"description": "In a graph, a cut is a partition of the vertices into 2 sets. A multiway cut is a partition of the vertices into 2 or more sets.",
"keywords": [
"cut",
"multiway cut",
"min-cut",
"max-cut",
"light edge"
],
"uci": "/graph-theory/cut",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/cut.html"
},
{
"type": "theorem",
"title": "Degree sum and number of edges",
"description": "In an undirected graph, the sum of degree of every vertex equals twice the number of edges. In a directed graph, the sum of in-degree of every vertex equals the sum of out-degree of every vertex which equals the number of edges.",
"uci": "/graph-theory/degree-sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/degree-sum.html"
},
{
"type": "theorem",
"title": "Adjacency matrix",
"description": "The adjacency matrix of a graph is a boolean matrix whose (i, j)th entry is true iff there is an edge from the ith vertex to the jth vertex.",
"uci": "/graph-theory/adj-matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/adj-matrix.html"
},
{
"type": "def",
"title": "Transpose of a graph",
"description": "The transpose of a directed graph is the graph obtained by flipping the direction of every edge.",
"uci": "/graph-theory/transpose",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/transpose.html"
},
{
"type": "def",
"title": "Topological sort",
"description": "A topological ordering of a directed graph is an ordering of its vertices such that if (u, v) is an edge then u precedes v in the ordering. The process of finding such an ordering is called topological sorting.",
"uci": "/graph-theory/toposort",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/toposort.html"
},
{
"type": "def",
"title": "Path in Graph",
"description": "In a graph, a path is a sequence of vertices such that all pairs of consecutive vertices are edges.",
"keywords": [
"path",
"simple path",
"walk",
"cycle",
"circuit",
"cyclic"
],
"uci": "/graph-theory/path",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/path.html"
},
{
"type": "theorem",
"title": "Triangle inequality of shortest paths",
"description": "\u03b4(u, v) + \u03b4(v, w) \u2265 \u03b4(u, w)",
"uci": "/graph-theory/shortest-paths/triangle-inequality",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/triangle-inequality.html"
},
{
"type": "theoremdef",
"title": "Edge relaxations",
"description": "A generic algorithm for finding shortest paths from a single source involves keeping an upper bound on the shortest-path-length to each vertex and successively updating it using operations called edge-relaxations.",
"uci": "/graph-theory/shortest-paths/relaxations",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/relaxations.html"
},
{
"type": "theoremdef",
"title": "Convergence of edge relaxations",
"description": "Intelligently choosing the order of relaxations can make the shortest-path-length estimate converge to the shortest-path-length.",
"uci": "/graph-theory/shortest-paths/relaxations-convergence",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/relaxations-convergence.html"
},
{
"type": "theorem",
"title": "Subpath of shortest path is shortest path",
"description": "Let p be a shortest path from u to v. Let q be a subpath of p from x to y. Then q is a shortest path from x to y.",
"uci": "/graph-theory/shortest-paths/shortest-subpath",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/shortest-subpath.html"
},
{
"type": "theoremdef",
"title": "Tree",
"description": "A tree is an undirected acyclic connected graph. It can also be defined as a graph where any 2 vertices have a unique simple path between them.",
"uci": "/graph-theory/trees/tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/tree.html"
},
{
"type": "def",
"title": "Spanning tree",
"description": "The spanning tree of an undirected graph G is a subgraph which is a tree and contains all the vertices of G.",
"keywords": [
"spanning tree",
"minimum spanning tree",
"maximum spanning tree",
"MST"
],
"uci": "/graph-theory/spanning-trees/spanning-tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/spanning-trees/spanning-tree.html"
},
{
"type": "theorem",
"title": "Tree iff acyclic and adding edge creates cycle",
"description": "A graph is a tree iff it is acyclic and adding an edge to it creates a cycle.",
"uci": "/graph-theory/trees/adding-edge-creates-cycle",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/adding-edge-creates-cycle.html"
},
{
"type": "theorem",
"title": "Adding edge between 2 trees gives a tree",
"description": "Let T1 and T2 be 2 trees which are connected components of an undirected graph. If an edge is added whose one endpoint is in T1 and the other endpoint is in T2, the resulting graph is a tree.",
"uci": "/graph-theory/trees/joining-2-trees-gives-tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/joining-2-trees-gives-tree.html"
},
{
"type": "theorem",
"title": "Tree iff connected and deleting edge disconnects",
"description": "A graph is a tree iff it is connected and deleting an edge from it disconnects it.",
"uci": "/graph-theory/trees/deleting-edge-disconnects",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/deleting-edge-disconnects.html"
},
{
"type": "def",
"title": "Rooted tree",
"description": "A directed graph is a rooted tree iff there is a vertex from which there is a unique simple path to every other vertex.",
"uci": "/graph-theory/trees/rooted-tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/rooted-tree.html"
},
{
"type": "def",
"title": "Shortest-path tree",
"description": "For a graph G, a shortest-path tree T is a tree rooted at a vertex s such that the unique path from s to v in T is a shortest path from s to v in G.",
"uci": "/graph-theory/shortest-paths/shortest-path-tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/shortest-path-tree.html"
},
{
"type": "theorem",
"title": "The undirected version of a rooted tree is a free tree",
"uci": "/graph-theory/trees/undirected-rooted-tree-is-free-tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/undirected-rooted-tree-is-free-tree.html"
},
{
"type": "theorem",
"title": "Acyclic predecessor graph is union of rooted trees",
"uci": "/graph-theory/trees/acyclic-predecessor-graph-is-union-of-rooted-trees",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/acyclic-predecessor-graph-is-union-of-rooted-trees.html"
},
{
"type": "theorem",
"title": "Edge relaxations: Predecessor subgraph is a rooted tree",
"description": "During relaxations from source s on a weighted graph, the predecessor subgraph is a rooted tree if there are no negative-weight cycles reachable from s.",
"uci": "/graph-theory/shortest-paths/relaxations-tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/relaxations-tree.html"
},
{
"type": "theorem",
"title": "Edge relaxations: Predecessor subgraph is a shortest-path tree after convergence",
"description": "After relaxations from source s on a weighted graph converge, the predecessor subgraph is a rooted tree.",
"uci": "/graph-theory/shortest-paths/relaxations-sp-tree",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/relaxations-sp-tree.html"
},
{
"type": "theorem",
"title": "Dijkstra's algorithm",
"description": "For a weighted graph without negative-weight edges, Dijkstra's algorithm finds a shortest-path tree.",
"uci": "/graph-theory/shortest-paths/dijkstra",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/dijkstra.html"
},
{
"type": "theorem",
"title": "Breadth-first search",
"description": "Properties of Breadth-first search in a graph.",
"keywords": [
"breadth-first",
"search",
"shortest path",
"bfs"
],
"uci": "/graph-theory/bfs",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/bfs.html"
},
{
"type": "def",
"title": "DAG",
"description": "A DAG is a Directed Acyclic Graph.",
"uci": "/graph-theory/dag",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dag.html"
},
{
"type": "theorem",
"title": "SCC graph is acyclic",
"uci": "/graph-theory/scc-graph-is-acyclic",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/scc-graph-is-acyclic.html"
},
{
"type": "def",
"title": "SCC graph",
"description": "Let G be a directed graph. The SCC graph of G, denoted as SCC(G), is a directed graph whose vertices correspond to strongly connected components of G. Let C1 and C2 be two SCCs of G. C1 and C2 will have an edge in SCC(G) iff there is an edge in G from some vertex in C1 to some vertex in C2.",
"uci": "/graph-theory/scc-graph",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/scc-graph.html"
},
{
"type": "theorem",
"title": "Removing cycles can make a path shorter",
"description": "Let p be a path from u to v which does not contain any negative cycles. Then there exists a simple path p' from u to v such that w(p') \u2264 w(p).",
"uci": "/graph-theory/simple-path-of-lower-weight",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/simple-path-of-lower-weight.html"
},
{
"type": "theorem",
"title": "Shortest path weight is -\u221e iff there is a negative-weight cycle",
"description": "\u03b4(u, v) = -\u221e iff there is some path from u to v containing a negative-weight cycle.",
"uci": "/graph-theory/shortest-paths/negw-cycle",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/shortest-paths/negw-cycle.html"
},
{
"type": "def",
"title": "Forest",
"description": "A forest is an undirected acyclic graph.",
"uci": "/graph-theory/forest",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/forest.html"
},
{
"type": "def",
"title": "Spanning forest",
"description": "The spanning forest of an undirected graph G is the union of the spanning trees of the connected components of G.",
"uci": "/graph-theory/spanning-trees/spanning-forest",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/spanning-trees/spanning-forest.html"
},
{
"type": "theorem",
"title": "Properties of DFS",
"description": "Properties of Depth-first search in a graph.",
"keywords": [
"DFS",
"depth-first search",
"parenthesis theorem",
"depth-first forest",
"start time",
"finish time"
],
"uci": "/graph-theory/dfs/dfs",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/dfs.html"
},
{
"type": "def",
"title": "DFS: Edge classification",
"description": "After performing DFS on a graph, the edges of the graph can be partitioned into 4 classes: tree edges, back edges, forward edges and cross edges.",
"keywords": [
"tree edge",
"back edge",
"forward edge",
"cross edge"
],
"uci": "/graph-theory/dfs/edge-classification",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/edge-classification.html"
},
{
"type": "theorem",
"title": "DFS: Reverse sorting by finish time gives topological ordering",
"description": "Performing DFS on a directed acyclic graph and sorting the vertices in descending order of finish times gives a topological ordering of vertices.",
"uci": "/graph-theory/dfs/toposort",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/toposort.html"
},
{
"type": "theorem",
"title": "DFS: Parenthesis theorem",
"description": "The DFS start and end times of vertices follow parenthesis structure.",
"uci": "/graph-theory/dfs/parens-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/parens-theorem.html"
},
{
"type": "theorem",
"title": "DFS: White-path theorem",
"description": "In the depth-first forest of a graph, v is a descendant of u iff at the time when u is visited, there is a path from u to v consisting entirely of white vertices.",
"uci": "/graph-theory/dfs/white-path-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/white-path-theorem.html"
},
{
"type": "theorem",
"title": "DFS on undirected graph gives spanning forest",
"description": "Running DFS on an undirected graph can be used to find a spanning forest of that graph.",
"uci": "/graph-theory/dfs/spanning-forest",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/spanning-forest.html"
},
{
"type": "theorem",
"title": "Directed graph is cyclic iff DFS gives back edges",
"description": "A directed graph contains a cycle iff DFS on that graph classifies some edges as back edges.",
"uci": "/graph-theory/dfs/cycle-iff-back-edges-directed",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/cycle-iff-back-edges-directed.html"
},
{
"type": "theorem",
"title": "DFS: Edge classification in undirected graphs",
"description": "In an undirected graph, one of (u, v) and (v, u) is a back edge and the other is either a tree edge or a forward edge.",
"uci": "/graph-theory/dfs/undirected-edge-classification",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/undirected-edge-classification.html"
},
{
"type": "theorem",
"title": "Undirected graph is cyclic iff DFS gives back edges",
"description": "An undirected graph contains a cycle iff DFS on that graph classifies some edges as back edges.",
"uci": "/graph-theory/dfs/cycle-iff-back-edges-undirected",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/cycle-iff-back-edges-undirected.html"
},
{
"type": "theorem",
"title": "Kosaraju's Algorithm",
"description": "Kosaraju's algorithm uses 2 depth first searches to find the strongly connected components of a graph in linear time.",
"keywords": [
"SCC",
"Kosaraju"
],
"uci": "/graph-theory/kosaraju-algo",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/kosaraju-algo.html"
},
{
"type": "theorem",
"title": "DFS: Online edge classification",
"description": "When an edge is explored during DFS, it can be classified as a tree edge, back edge, forward edge or a cross edge in constant time.",
"uci": "/graph-theory/dfs/online-edge-classification",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/online-edge-classification.html"
},
{
"type": "theoremdef",
"title": "DFS: low",
"uci": "/graph-theory/dfs/low",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/dfs/low.html"
},
{
"type": "theorem",
"title": "In a connected graph (V, E), |E| \u2265 |V| - 1",
"uci": "/graph-theory/number-of-edges-in-connected-graph",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/number-of-edges-in-connected-graph.html"
},
{
"type": "def",
"title": "Bridge in graph",
"keywords": [
"bridge",
"cut-edge"
],
"description": "An edge in an undirected graph is called a bridge (or cut-edge) iff deleting that edge disconnects the connected component to which that edge belongs.",
"uci": "/graph-theory/bridge",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/bridge.html"
},
{
"type": "theorem",
"title": "Spanning forest contains all bridges",
"description": "Let G be an undirected graph. Every spanning forest of G contains all the bridges in G.",
"uci": "/graph-theory/spanning-trees/spanning-forest-contains-all-bridges",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/spanning-trees/spanning-forest-contains-all-bridges.html"
},
{
"type": "theorem",
"title": "Deleting bridge from graph gives 2 components",
"description": "If a bridge is deleted from a connected graph, the resulting graph contains 2 connected components.",
"uci": "/graph-theory/deleting-bridge-gives-2-components",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/deleting-bridge-gives-2-components.html"
},
{
"type": "theorem",
"title": "Deleting edge from tree gives 2 trees",
"description": "If an edge is deleted from a tree, the resulting graph contains 2 connected components which are trees.",
"uci": "/graph-theory/trees/deleting-edge-gives-2-trees",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/deleting-edge-gives-2-trees.html"
},
{
"type": "theorem",
"title": "Edge replacement in spanning forest using a cut",
"description": "Let e be an edge crossing a cut of a graph G. Let F be a spanning forest of G which does not contain e. Then we can obtain a different spanning forest of G by replacing an edge in F which crosses the cut by e. Consequently, if e is a light edge of the cut, the weight of the new spanning forest either reduces or stays the same.",
"uci": "/graph-theory/spanning-trees/edge-replacement",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/spanning-trees/edge-replacement.html"
},
{
"type": "theorem",
"title": "Generic Greedy MSF Growth Algorithm (GGMSFGA)",
"description": "The Generic Greedy MSF Growth Algorithm (GGMSFGA) is a generic algorithm for finding the MSF of an undirected graph. GGMSFA maintains a forest F which is a subgraph of some MSF. In each iteration, it chooses a cut C which respects F and adds a light edge of C to F.",
"uci": "/graph-theory/spanning-trees/ggmsfga",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/spanning-trees/ggmsfga.html"
},
{
"type": "theorem",
"title": "|E| = |V| - 1 in trees",
"uci": "/graph-theory/trees/e-is-v-minus-1",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/e-is-v-minus-1.html"
},
{
"type": "theorem",
"title": "Tree has at least 2 leaves",
"description": "In a tree with at least 2 vertices, there are at least 2 leaves.",
"uci": "/graph-theory/trees/at-least-2-leaves",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/at-least-2-leaves.html"
},
{
"type": "theorem",
"title": "G = (V, E) is a tree iff G is acyclic and |E| = |V|-1",
"uci": "/graph-theory/trees/acyclic-and-e-is-v-minus-1",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/acyclic-and-e-is-v-minus-1.html"
},
{
"type": "theorem",
"title": "G = (V, E) is a tree iff G is connected and |E| = |V|-1",
"uci": "/graph-theory/trees/connected-and-e-is-v-minus-1",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/graph-theory/trees/connected-and-e-is-v-minus-1.html"
},
{
"type": "def",
"title": "Hitting interval problem",
"description": "Given several input intervals with costs and a value \u03b4, find x that minimizes the cost of the input intervals that intersect the interval (x, x+\u03b4).",
"uci": "/geometry/hitting-interval",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/geometry/hitting-interval.html"
},
{
"type": "theorem",
"title": "Hitting interval problem: upper bound for small intervals",
"description": "For the hitting interval problem, if all input intervals are small, then it is possible to find a solution with bounded cost.",
"uci": "/geometry/hitting-interval-ub-for-small-intervals",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/geometry/hitting-interval-ub-for-small-intervals.html"
},
{
"type": "def",
"title": "Matroid",
"description": "A matroid is the generalization of linear independence from linear algebra.",
"keywords": [
"matroid",
"hereditary",
"exchange",
"independent",
"dependent"
],
"uci": "/matroids/matroid",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/matroid.html"
},
{
"type": "theorem",
"title": "Uniform matroid",
"description": "Matroid where a set is independent iff its cardinality is less than a threshold.",
"uci": "/matroids/examples/uniform",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/examples/uniform.html"
},
{
"type": "theorem",
"title": "Graphic matroid",
"description": "The edges of a graph form a matroid where the independent sets are acyclic subsets.",
"uci": "/matroids/examples/graphic",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/examples/graphic.html"
},
{
"type": "def",
"title": "Matroid: weight function",
"description": "A weight function assigns a weight to every element of a matroid.",
"uci": "/matroids/weights/weight-function",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/weights/weight-function.html"
},
{
"type": "theoremdef",
"title": "Restriction of a matroid",
"uci": "/matroids/restriction",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/restriction.html"
},
{
"type": "def",
"title": "Matroid: circuit",
"description": "In a matroid, a circuit is a minimally dependent set.",
"keywords": [
"circuit",
"loop"
],
"uci": "/matroids/circuit",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/circuit.html"
},
{
"type": "def",
"title": "Matroid: rank",
"description": "Rank of a matroid is the size of the largest independent set.",
"uci": "/matroids/rank",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/rank.html"
},
{
"type": "def",
"title": "Matroid: basis",
"description": "The basis of a matroid is a maximal independent set.",
"uci": "/matroids/basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/basis.html"
},
{
"type": "theorem",
"title": "Matroid: basis iff size is rank",
"keywords": [
"all bases have same size"
],
"uci": "/matroids/basis-iff-size-is-rank",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/basis-iff-size-is-rank.html"
},
{
"type": "theorem",
"title": "Matroid: greedy algorithm",
"description": "A greedy algorithm can compute the max-weight independent set of X.",
"uci": "/matroids/weights/greedy",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/weights/greedy.html"
},
{
"type": "theorem",
"title": "Matroid: expanding to basis",
"description": "Every independent set can be expanded to a basis.",
"uci": "/matroids/expand-to-basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/expand-to-basis.html"
},
{
"type": "theorem",
"title": "Matroid: basis of set increment",
"description": "Complete characterization of basis of X+e when rank(X+e) = rank(X) + 1.",
"uci": "/matroids/basis-of-set-increment",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/basis-of-set-increment.html"
},
{
"type": "theorem",
"title": "Matroid: rank of set increment",
"description": "rank(X) \u2264 rank(X + e) \u2264 rank(X) + 1",
"uci": "/matroids/rank-of-set-increment",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/rank-of-set-increment.html"
},
{
"type": "theorem",
"title": "Matroid: dependent iff has circuit",
"description": "In a matroid, a set is dependent iff it contains a circuit.",
"uci": "/matroids/dependent-iff-has-circuit",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/dependent-iff-has-circuit.html"
},
{
"type": "theorem",
"title": "Matroid: non-disjoint circuits",
"description": "If C1 and C2 are distinct non-disjoint circuits in a matroid and x \u2208 C1 \u2229 C2, then C1 \u222a C2 - x is dependent.",
"uci": "/matroids/non-disjoint-circuits",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/non-disjoint-circuits.html"
},
{
"type": "theorem",
"title": "Matroid: unique circuit",
"description": "If A is an independent set and A + e is dependent, then A + e contains a unique circuit C. Moreover, we can remove an element f \u2260 e from C such that A + e - f is independent.",
"uci": "/matroids/unique-circuit",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/unique-circuit.html"
},
{
"type": "theorem",
"title": "Incremental max-weight basis",
"uci": "/matroids/weights/incremental",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/weights/incremental.html"
},
{
"type": "theoremdef",
"title": "Binomial Coefficient",
"keywords": [
"binom",
"choose"
],
"description": "A binomial coefficient, denoted by C(n, k), is the number of ways to choose k elements out of n distinct elements.",
"uci": "/combinatorics/bin-coeff/bin-coeff",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/bin-coeff.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Decrement identities",
"description": "We can compute C(n, k) in 1 step if we know one of C(n-1, k), C(n, k-1) or C(n-1, k-1).",
"uci": "/combinatorics/bin-coeff/decrement",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/decrement.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Bulk decrement",
"description": "C(n, i) * C(i, k) = C(n, k) * C(n-k, i-k)",
"uci": "/combinatorics/bin-coeff/bulk-decrement",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/bulk-decrement.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Additive recursion",
"description": "C(n, k) = C(n-1, k) + C(n-1, k-1)",
"uci": "/combinatorics/bin-coeff/add-recursion",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/add-recursion.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Sum 2",
"uci": "/combinatorics/bin-coeff/sum-2",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/sum-2.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Sum 4",
"uci": "/combinatorics/bin-coeff/sum-4",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/sum-4.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Sum 3",
"uci": "/combinatorics/bin-coeff/sum-3",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/sum-3.html"
},
{
"type": "theorem",
"title": "Number of tuples with fixed sum",
"description": "The number of tuples of length n of non-negative numbers whose sum is s is C(s+n-1, n-1).",
"uci": "/combinatorics/tuples-with-fixed-sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/tuples-with-fixed-sum.html"
},
{
"type": "theorem",
"title": "Number of tuples with bounded sum",
"description": "The number of tuples of length n of non-negative numbers whose sum is at most s is C(s+n, n) \u2264 (s+1)^n.",
"uci": "/combinatorics/tuples-with-bounded-sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/tuples-with-bounded-sum.html"
},
{
"type": "theorem",
"title": "Algorithm for enumerating tuples with bounded sum",
"description": "An algorithm that outputs all n-tuples of non-negative integers having sum at most s in time O(C(n+s,n)).",
"uci": "/combinatorics/enum-tuples-with-bounded-sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/enum-tuples-with-bounded-sum.html"
},
{
"type": "theorem",
"title": "Bin packing: config-enum algorithm",
"description": "An algorithm for bin packing that enumerates all bin configurations and then considers all combinations of those combinations.",
"uci": "/packing/bp-brute-algo",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/bp-brute-algo.html"
},
{
"type": "theorem",
"title": "1BP: APTAS",
"uci": "/packing/1d/aptas",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/aptas.html"
},
{
"type": "def",
"title": "Group",
"description": "A group is a set along with a binary operator which satisfies certain properties.",
"uci": "/abstract-algebra/groups/group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/group.html"
},
{
"type": "def",
"title": "Coset",
"metadata": "A coset is a set obtained by multiplying every element of a subgroup by a group element.",
"uci": "/abstract-algebra/cosets/coset",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/coset.html"
},
{
"type": "theorem",
"title": "Size of coset equals size of subset",
"description": "Size of a coset of a subset equals the size of the subset",
"uci": "/abstract-algebra/cosets/size",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/size.html"
},
{
"type": "theorem",
"title": "Inverse of a coset",
"description": "(gH)^(-1) = H^(-1)g^(-1)",
"uci": "/abstract-algebra/cosets/inverse",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/inverse.html"
},
{
"type": "theorem",
"title": "For subset H of a group, a(bH) = (ab)H and (aH)b = a(Hb)",
"description": "Multiplication of a coset by a group element is associative. For subset H of a group, a(bH) = (ab)H and (aH)b = a(Hb).",
"uci": "/abstract-algebra/cosets/associativity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/associativity.html"
},
{
"type": "def",
"title": "Ring",
"description": "A ring is a set with 2 operations (addition and multiplication) that satisfies certain properties.",
"uci": "/abstract-algebra/rings/ring",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/ring.html"
},
{
"type": "def",
"title": "Polynomial",
"uci": "/polynomials/polynomial",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/polynomial.html"
},
{
"type": "def",
"title": "GCD of polynomials",
"description": "The GCD of a set of polynomials over a ring with unity is a largest degree monic polynomial which divides all polynomials in that set. Since 1 divides all polynomials, every set of polynomials has a GCD.",
"uci": "/polynomials/gcd",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/gcd.html"
},
{
"type": "def",
"title": "Irreducible polynomial",
"description": "A polynomial is irreducible iff it cannot be expressed as a product of polynomials of lower degree.",
"uci": "/polynomials/irreducible",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/irreducible.html"
},
{
"type": "theorem",
"title": "Degree of product of polynomials",
"description": "deg(pq) \u2264 deg(p) + deg(q). If coefficients of p and q are from an integral domain, deg(pq) = deg(p) + deg(q).",
"uci": "/polynomials/degree-of-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/degree-of-product.html"
},
{
"type": "theorem",
"title": "Zero divisors of a polynomial",
"description": "Ring R has no zero divisors iff the ring of polynomials R[x] has no zero divisors",
"uci": "/polynomials/zero-divisors",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/zero-divisors.html"
},
{
"type": "theorem",
"title": "Degree of factor is less than degree of polynomial",
"description": "If a(x) divides p(x), degree of a(x) lies between 0 and deg(p).",
"uci": "/polynomials/degree-of-factor",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/degree-of-factor.html"
},
{
"type": "def",
"title": "Polynomial divisibility",
"description": "A polynomial p(x) is divisible in F[x] by q(x) iff there exists a polynomial r(x) such that p(x), q(x), r(x) are in F[x] and p(x) = q(x)r(x).",
"uci": "/polynomials/divisibility",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/divisibility.html"
},
{
"type": "theorem",
"title": "q(x)F[x] is in p(x)F[x] iff p(x) divides q(x)",
"uci": "/polynomials/subideal-condition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/subideal-condition.html"
},
{
"type": "theorem",
"title": "Degree of sum of polynomials",
"description": "The degree of sum of 2 polynomials is at most the maximum of the degrees of those polynomials.",
"uci": "/polynomials/degree-of-sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/degree-of-sum.html"
},
{
"type": "theorem",
"title": "Polynomials of a ring form a ring",
"description": "The set of all polynomials is a ring if the coefficients are from a ring.",
"uci": "/polynomials/ring",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/ring.html"
},
{
"type": "def",
"title": "Vector",
"description": "A vector is a sequence of numbers with an element-wise addition operation and a scalar multiplication operation.",
"uci": "/linear-algebra/vector",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector.html"
},
{
"type": "def",
"title": "Dot-product of vectors",
"metadata": "The dot product of vectors u and v is the sum of product of corresponding elements in u and v.",
"uci": "/linear-algebra/dot",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/dot.html"
},
{
"type": "def",
"title": "p-norm",
"description": "The p-norm is a function which maps a vector to a number",
"uci": "/linear-algebra/p-norm",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/p-norm.html"
},
{
"type": "def",
"title": "Ring isomorphism",
"description": "A ring isomorphism is a bijective function \u03d5 such that \u03d5(a+b) = \u03d5(a) + \u03d5(b) and \u03d5(ab) = \u03d5(a)\u03d5(b).",
"uci": "/abstract-algebra/rings/isomorphism/isomorphism",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/isomorphism/isomorphism.html"
},
{
"type": "def",
"title": "Integral Domain",
"description": "R is an integral domain iff R is a commutative ring with unity and R has no zero-divisors.",
"uci": "/abstract-algebra/rings/intdom",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/intdom.html"
},
{
"type": "theorem",
"title": "Comparing coefficients of a polynomial with disjoint variables",
"description": "Let there be a (possibly multi-variate) polynomial over an integral domain where each variable is present in at most one term. If the polynomial evaluates to 0 for all inputs, then all coefficients of the polynomial are zero.",
"uci": "/polynomials/compare-coeff-disjoint-var",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/compare-coeff-disjoint-var.html"
},
{
"type": "theorem",
"title": "Characteristic of ring equals additive order of unity",
"uci": "/abstract-algebra/rings/char-equals-additive-order-of-unity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/char-equals-additive-order-of-unity.html"
},
{
"type": "theorem",
"title": "0x = 0 = x0",
"description": "Let R be a ring. For all elements x in R, 0x = 0 = x0.",
"uci": "/abstract-algebra/rings/0x-is-0",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/0x-is-0.html"
},
{
"type": "theorem",
"title": "(-a)b = a(-b) = -ab",
"uci": "/abstract-algebra/rings/minus-outside",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/minus-outside.html"
},
{
"type": "def",
"title": "Ideal",
"description": "An ideal I is a subring of R with the absorption property, i.e. aI = I for all a in R.",
"uci": "/abstract-algebra/rings/ideal",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/ideal.html"
},
{
"type": "def",
"title": "Field",
"description": "(R, +, *) is a field iff (R, +) and (R, *) are commutative groups and the distributive property holds.",
"uci": "/abstract-algebra/rings/field",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/field.html"
},
{
"type": "def",
"title": "Vector Space",
"description": "A vector space is a set of vectors along with a scalar multiplication operation.",
"uci": "/linear-algebra/vector-spaces/vector-space",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/vector-space.html"
},
{
"type": "theoremdef",
"title": "Linear independence",
"description": "A set of vectors are linearly independent iff no finite linear combination of them with some positive coefficients is 0.",
"uci": "/linear-algebra/vector-spaces/linindep",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/linindep.html"
},
{
"type": "theorem",
"title": "Incrementing a linearly independent set",
"keywords": [
"increment",
"expand",
"increase",
"grow"
],
"description": "If S is linearly independent and v is not a linear combination of S, then S+{v} is linearly independent.",
"uci": "/linear-algebra/vector-spaces/linindep-increment",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/linindep-increment.html"
},
{
"type": "theorem",
"title": "Zeros in vector space",
"description": "0v = 0, a0 = 0, (av = 0 iff a=0 or v=0).",
"uci": "/linear-algebra/vector-spaces/zero",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/zero.html"
},
{
"type": "theorem",
"title": "Negation in vector space",
"description": "-v = (-1)v. -(av) = (-a)v = a(-v).",
"uci": "/linear-algebra/vector-spaces/negation",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/negation.html"
},
{
"type": "def",
"title": "Span",
"description": "The span of a set of vectors is the set of all finite linear combinations of those vectors.",
"uci": "/linear-algebra/vector-spaces/span",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/span.html"
},
{
"type": "theorem",
"title": "Decrementing a span",
"keywords": [
"decrement",
"contract",
"reduce",
"shrink"
],
"description": "If S has a linearly dependent element v, then span(S-{v}) = span(S).",
"uci": "/linear-algebra/vector-spaces/span-decrement",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/span-decrement.html"
},
{
"type": "def",
"title": "Inner product space",
"description": "An inner product space is a vector space equipped with an inner product operator, which is an abstract generalization of the dot product.",
"uci": "/linear-algebra/inner-product-spaces/inner-product-space",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/inner-product-space.html"
},
{
"type": "theorem",
"title": "Inner product is anti-linear in second argument",
"description": "< u, av > = conj(a) < u, v > and < u, v1+v2 > = < u, v1 > + < u, v2 >",
"uci": "/linear-algebra/inner-product-spaces/antilin-in-2nd",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/antilin-in-2nd.html"
},
{
"type": "theorem",
"title": "Pythagorean theorem",
"description": "If < u, v > = 0, < u, u > + < v, v > = < u+v, u+v >.",
"uci": "/linear-algebra/inner-product-spaces/pythagorean-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/pythagorean-theorem.html"
},
{
"type": "def",
"title": "Norm",
"description": "norm(x) = sqrt(< x, x >)",
"uci": "/linear-algebra/inner-product-spaces/norm",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/norm.html"
},
{
"type": "def",
"title": "Orthogonality and orthonormality",
"description": "A set of vectors is orthogonal iff all the vectors are non-zero and the inner product of any 2 different vectors is 0. A set of vectors is orthonormal if they are orthogonal and the norm of each vector is 1.",
"uci": "/linear-algebra/inner-product-spaces/orthogonality",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/orthogonality.html"
},
{
"type": "theoremdef",
"title": "Gram-Schmidt Process",
"description": "The Gram-Schmidt process takes a set of n linearly independent vectors as input and outputs a set of n orthogonal vectors which have the same span.",
"uci": "/linear-algebra/inner-product-spaces/gram-schmidt-process",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/gram-schmidt-process.html"
},
{
"type": "theorem",
"title": "A set of mutually orthogonal vectors is linearly independent",
"uci": "/linear-algebra/inner-product-spaces/ortho-vectors-are-linindep",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/ortho-vectors-are-linindep.html"
},
{
"type": "theorem",
"title": "Zero in inner product",
"description": "< 0, v > = < v, 0 > = 0.",
"uci": "/linear-algebra/inner-product-spaces/zero",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/zero.html"
},
{
"type": "theorem",
"title": "Cauchy-Schwarz Inequality",
"description": "< u, v >\u00b2 \u2264 < u, u > < v, v >",
"uci": "/linear-algebra/inner-product-spaces/cauchy-schwarz-inequality",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/cauchy-schwarz-inequality.html"
},
{
"type": "theorem",
"title": "Triangle inequality",
"description": "|x+y| \u2264 |x| + |y|",
"uci": "/linear-algebra/inner-product-spaces/triangle-inequality",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/triangle-inequality.html"
},
{
"type": "theorem",
"title": "x and y are parallel iff \u2225x\u2225\u00b2\u2225y\u2225\u00b2 = |< x, y >|\u00b2.",
"description": "Two vectors are parallel iff the absolute value of their dot product equals the product of their norms.",
"uci": "/linear-algebra/inner-product-spaces/parallelism",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/parallelism.html"
},
{
"type": "theorem",
"title": "Coordinatization over orthogonal vectors",
"description": "Let (x1, x2, ..., xn) be orthogonal vectors. Coordinate of v along xi is (v.xi)/(xi.x).",
"uci": "/linear-algebra/inner-product-spaces/coordinatization",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/coordinatization.html"
},
{
"type": "def",
"title": "Linear transformation",
"description": "A linear transformation is a linear function mapping one vector space to another.",
"uci": "/linear-algebra/linear-transformation/linear-transformation",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/linear-transformation.html"
},
{
"type": "def",
"title": "Symmetric operator",
"description": "A linear transformation L is a symmetric operator iff L(u)v = uL(v).",
"uci": "/linear-algebra/linear-transformation/symmetric-operator",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/symmetric-operator.html"
},
{
"type": "theorem",
"title": "Composition of linear transformations",
"description": "Composition of linear transformations is a linear transformation.",
"uci": "/linear-algebra/linear-transformation/composition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/composition.html"
},
{
"type": "theorem",
"title": "Vector space isomorphism is an equivalence relation",
"uci": "/linear-algebra/linear-transformation/isomorphism-equiv",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/isomorphism-equiv.html"
},
{
"type": "theorem",
"title": "Being a field is preserved under isomorphism",
"uci": "/abstract-algebra/rings/isomorphism/field",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/isomorphism/field.html"
},
{
"type": "theorem",
"title": "A finite integral domain is a field",
"uci": "/abstract-algebra/rings/finite-integral-domain-is-field",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/finite-integral-domain-is-field.html"
},
{
"type": "theorem",
"title": "A field is an integral domain",
"uci": "/abstract-algebra/rings/field-is-integral-domain",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/field-is-integral-domain.html"
},
{
"type": "theorem",
"title": "p(x)F[x] = F[x] iff p is a non-zero constant",
"uci": "/polynomials/principal-ideal-trivial",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/principal-ideal-trivial.html"
},
{
"type": "theorem",
"title": "Polynomial division theorem",
"description": "If a and b are polynomials, a can be uniquely expressed as bq + r where deg(r) < deg(b).",
"uci": "/polynomials/division-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/division-theorem.html"
},
{
"type": "theorem",
"title": "Polynomial GCD theorem",
"description": "The GCD of polynomials is unique and equals their least degree monic linear combination.",
"uci": "/polynomials/gcd-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/gcd-theorem.html"
},
{
"type": "theorem",
"title": "Factor theorem",
"description": "(x-a) is a factor of p(x) iff p(a) = 0",
"uci": "/polynomials/factor-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/factor-theorem.html"
},
{
"type": "theorem",
"title": "The ideal generated by an irreducible polynomial is maximal",
"uci": "/polynomials/irred-ideal-is-maximal",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/irred-ideal-is-maximal.html"
},
{
"type": "theorem",
"title": "Product of linear factors is a factor",
"description": "If (x-a1), (x-a2), ..., (x-an) are factors of p(x), then (x-a1)(x-a2)...(x-an) is a factor of p(x).",
"uci": "/polynomials/product-of-linear-factors-is-factor",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/product-of-linear-factors-is-factor.html"
},
{
"type": "theorem",
"title": "A polynomial of degree n has at most n zeros",
"description": "A polynomial over a field with degree n has at most n zeros",
"uci": "/polynomials/at-most-degree-zeros",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/at-most-degree-zeros.html"
},
{
"type": "def",
"title": "Homomorphism on groups",
"description": "A homomorphism \u03d5 is a function from one group to another such that \u03d5(ab) = \u03d5(a)\u03d5(b).",
"uci": "/abstract-algebra/groups/homomorphism/homomorphism",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/homomorphism/homomorphism.html"
},
{
"type": "theorem",
"title": "Mapping of power is power of mapping",
"description": "\u03d5(g^k) = \u03d5(g)^k",
"uci": "/abstract-algebra/groups/homomorphism/mapping-of-power-is-power-of-mapping",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/homomorphism/mapping-of-power-is-power-of-mapping.html"
},
{
"type": "def",
"title": "Isomorphism on Groups",
"description": "Two groups are isomorphic iff they are related via a bijection \u03d5 such that \u03d5(ab) = \u03d5(a)\u03d5(b).",
"uci": "/abstract-algebra/groups/isomorphism/group-isomorphism",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/group-isomorphism.html"
},
{
"type": "theorem",
"title": "Inverse of a group isomorphism is a group isomorphism",
"uci": "/abstract-algebra/groups/isomorphism/inverse",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/inverse.html"
},
{
"type": "theorem",
"title": "Abelianness is invariant under isomorphism",
"description": "If G is isomorphic to H and G is abelian, then H is abelian.",
"uci": "/abstract-algebra/groups/isomorphism/abelianness",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/abelianness.html"
},
{
"type": "theorem",
"title": "Isomorphism of groups is an equivalence relation",
"uci": "/abstract-algebra/groups/isomorphism/equivalence-relation",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/equivalence-relation.html"
},
{
"type": "theorem",
"title": "Cayley's Theorem",
"description": "Every group is isomorphic to a permutation group",
"uci": "/abstract-algebra/groups/isomorphism/cayleys-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/cayleys-theorem.html"
},
{
"type": "theorem",
"title": "Cyclicness is invariant under isomorphism",
"description": "If < a > is isomorphic to G via \u03d5, then G = < \u03d5(a) >.",
"uci": "/abstract-algebra/groups/isomorphism/cyclicness-is-invariant-under-isomorphism",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/cyclicness-is-invariant-under-isomorphism.html"
},
{
"type": "theorem",
"title": "Order of elements is invariant under isomorphism",
"description": "If G is isomorphic to H, then G and H have the same frequencies of orders of elements.",
"uci": "/abstract-algebra/groups/isomorphism/order-of-elements",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/order-of-elements.html"
},
{
"type": "theorem",
"title": "Inverse of product of two elements of a group",
"description": "(a*b)^(-1) = (b^(-1)) * (a^(-1))",
"uci": "/abstract-algebra/groups/inverse-of-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/inverse-of-product.html"
},
{
"type": "theorem",
"title": "Identity of a group is unique",
"description": "Identity of a group is unique.",
"uci": "/abstract-algebra/groups/identity-is-unique",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/identity-is-unique.html"
},
{
"type": "theorem",
"title": "Order of element in finite group is finite",
"description": "Let g be an element of the group G. If G is finite, then order(g) is finite.",
"uci": "/abstract-algebra/groups/order-of-element-in-finite-group-is-finite",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/order-of-element-in-finite-group-is-finite.html"
},
{
"type": "def",
"title": "Subgroup",
"description": "If H is a subset of a group G and H is also a group, then H is said to be a subgroup of G.",
"uci": "/abstract-algebra/groups/subgroup",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/subgroup.html"
},
{
"type": "theoremdef",
"title": "Permutation group",
"description": "A permutation group on a finite set X is a group of bijections on X, where the group operator is function composition.",
"keywords": [
"permutation",
"symmetric group",
"cycle",
"transposition"
],
"uci": "/abstract-algebra/groups/permutation-groups/permutation-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/permutation-group.html"
},
{
"type": "theorem",
"title": "Product of cycles and a transposition",
"uci": "/abstract-algebra/groups/permutation-groups/product-of-cycles-and-transposition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/product-of-cycles-and-transposition.html"
},
{
"type": "theorem",
"title": "Permutation is disjoint cycle product",
"description": "Every permutation can be written as the product of a unique set of disjoint cycles.",
"uci": "/abstract-algebra/groups/permutation-groups/permutation-is-disjoint-cycle-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/permutation-is-disjoint-cycle-product.html"
},
{
"type": "theorem",
"title": "Permutation is transposition product",
"description": "Every finite permutation can be written as a product of transpositions.",
"uci": "/abstract-algebra/groups/permutation-groups/permutation-is-transposition-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/permutation-is-transposition-product.html"
},
{
"type": "theorem",
"title": "Product of disjoint cycles is commutative",
"uci": "/abstract-algebra/groups/permutation-groups/product-of-disjoint-cycles-is-commutative",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/product-of-disjoint-cycles-is-commutative.html"
},
{
"type": "def",
"title": "Canonical cycle notation of a permutation",
"description": "Canonical cycle notation is a unique way of writing a permutation as a product of disjoint cycles.",
"uci": "/abstract-algebra/groups/permutation-groups/canonical-cycle-notation",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/canonical-cycle-notation.html"
},
{
"type": "theoremdef",
"title": "Parity of a permutation",
"description": "If a permutation can be written as a product of only an odd number of transpositions, it is called an odd permutation. If a permutation can be written as a product of only an even number of transpositions, it is called an even permutation. Every permutation is either an odd permutation or an even permutation.",
"uci": "/abstract-algebra/groups/permutation-groups/parity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/parity.html"
},
{
"type": "theorem",
"title": "Transposition bijects even and odd permutations",
"description": "There is a bijection between even and odd permutations. The bijective function multiplies a permutation by a transposition.",
"uci": "/abstract-algebra/groups/permutation-groups/transposition-bijects-even-and-odd-permutations",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/transposition-bijects-even-and-odd-permutations.html"
},
{
"type": "def",
"title": "Normal Subgroup",
"description": "H is a normal subgroup of G iff gH = Hg for all g in G.",
"uci": "/abstract-algebra/groups/normal-subgroup",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/normal-subgroup.html"
},
{
"type": "theorem",
"title": "Product of normal cosets is well-defined",
"description": "Let N be a normal subgroup. Then the product (aN)(bN) = (ab)N is well-defined.",
"uci": "/abstract-algebra/cosets/product-of-normal-cosets",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/product-of-normal-cosets.html"
},
{
"type": "theoremdef",
"title": "Factor group",
"description": "The group of all cosets of a normal subgroup is called the factor group or quotient group.",
"uci": "/abstract-algebra/groups/factor-groups/factor-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/factor-groups/factor-group.html"
},
{
"type": "theorem",
"title": "External direct product is a group",
"description": "For groups G and H, G \u00d7 H is a group",
"uci": "/abstract-algebra/groups/external-direct-product-is-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/external-direct-product-is-group.html"
},
{
"type": "theorem",
"title": "Order of element in external direct product",
"description": "order of (g, h) in G \u00d7 H = lcm(order(g), order(h))",
"uci": "/abstract-algebra/groups/order-of-element-in-external-direct-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/order-of-element-in-external-direct-product.html"
},
{
"type": "theorem",
"title": "Inverse of a group element is unique",
"description": "Inverse of a group element is unique.",
"uci": "/abstract-algebra/groups/inverse-is-unique",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/inverse-is-unique.html"
},
{
"type": "theorem",
"title": "gH = H iff g in H",
"description": "Coset of a subgroup equals the subgroup iff the representative is in the subgroup.",
"uci": "/abstract-algebra/cosets/coset-equals-subgroup-iff-elem-in-subgroup",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/coset-equals-subgroup-iff-elem-in-subgroup.html"
},
{
"type": "theorem",
"title": "Product of ideal cosets is well-defined",
"description": "Let I be an ideal. The product of cosets (a+I)(b+I) = ab+I is well-defined.",
"uci": "/abstract-algebra/cosets/product-of-ideal-cosets",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/product-of-ideal-cosets.html"
},
{
"type": "theoremdef",
"title": "Quotient Ring",
"description": "Let I be an ideal of R. The quotient ring R/I is the set of all additive cosets of I.",
"uci": "/abstract-algebra/rings/quotient-ring",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/quotient-ring.html"
},
{
"type": "theorem",
"title": "Two cosets are either identical or disjoint",
"description": "Two cosets are either identical or disjoint.",
"uci": "/abstract-algebra/cosets/cosets-are-either-identical-or-disjoint",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/cosets-are-either-identical-or-disjoint.html"
},
{
"type": "theorem",
"title": "Lagrange's Theorem",
"description": "Order of subgroup divides order of group. Furthermore, number of cosets equals ratio of orders of group and subgroup.",
"uci": "/abstract-algebra/cosets/lagranges-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/cosets/lagranges-theorem.html"
},
{
"type": "theorem",
"title": "I is a maximal ideal iff R/I is a field",
"description": "Let I be an ideal of R, a commutative ring with unity. Then I is maximal in R iff R/I is a field.",
"uci": "/abstract-algebra/rings/maximal-ideal-field",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/maximal-ideal-field.html"
},
{
"type": "theorem",
"title": "I is a prime ideal iff R/I is an integral domain",
"description": "Let I be an ideal of R, a commutative ring with unity. Then I is prime in R iff R/I is an integral domain.",
"uci": "/abstract-algebra/rings/prime-ideal-intdom",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/prime-ideal-intdom.html"
},
{
"type": "theorem",
"title": "Conditions for a subset to be a subgroup",
"description": "Conditions for a subset to be a subgroup.",
"uci": "/abstract-algebra/groups/subgroup-condition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/subgroup-condition.html"
},
{
"type": "def",
"title": "Cyclic Group",
"description": "A cyclic group with generator g is the group of all powers of g.",
"uci": "/abstract-algebra/groups/cyclic-groups/cyclic-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/cyclic-group.html"
},
{
"type": "theorem",
"title": "Cyclic groups are isomorphic to Z or Zn",
"description": "A cyclic group of infinite order is isomorphic to Z. A cyclic group of order n is isomorphic to Zn.",
"uci": "/abstract-algebra/groups/cyclic-groups/isomorphic-to-z",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/isomorphic-to-z.html"
},
{
"type": "theorem",
"title": "Condition for a subset to be a subgroup",
"description": "Condition for a subset to be a subgroup.",
"uci": "/abstract-algebra/groups/subgroup-condition-2",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/subgroup-condition-2.html"
},
{
"type": "theoremdef",
"title": "F[x]/p(x): A ring",
"description": "F[x]/p(x) is the ring of all polynomials modulo p(x).",
"uci": "/polynomials/modulo-ring",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/modulo-ring.html"
},
{
"type": "theorem",
"title": "The ring F[x]/p(x) is a field iff p is irreducible",
"uci": "/polynomials/modulo-field",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/modulo-field.html"
},
{
"type": "theorem",
"title": "Condition for being a subspace",
"description": "Let W be a subset of vector space V. Then W is a subspace of V iff W is closed under addition and scalar multiplication.",
"uci": "/linear-algebra/vector-spaces/subspace-condition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/subspace-condition.html"
},
{
"type": "theorem",
"title": "Range of linear transformation is subspace of codomain",
"uci": "/linear-algebra/linear-transformation/range-is-subspace",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/range-is-subspace.html"
},
{
"type": "theorem",
"title": "Kernel of linear transformation is subspace of domain",
"uci": "/linear-algebra/linear-transformation/kernel-is-subspace",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/kernel-is-subspace.html"
},
{
"type": "theorem",
"title": "Conditions for a subset of a ring to be a subring",
"uci": "/abstract-algebra/rings/subring-condition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/subring-condition.html"
},
{
"type": "theoremdef",
"title": "Principal ideal",
"description": "A principal ideal is a multiplicative coset",
"uci": "/abstract-algebra/rings/principal-ideal",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/principal-ideal.html"
},
{
"type": "theorem",
"title": "Every ideal in F[x] is principal",
"description": "Every ideal the ring of polynomials of a field is a principal ideal",
"uci": "/polynomials/every-ideal-is-principal",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/every-ideal-is-principal.html"
},
{
"type": "theorem",
"title": "F[x]/p(x) is isomorphic to F[x]/p(x)F[x]",
"uci": "/polynomials/modulo-isomorphic",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/modulo-isomorphic.html"
},
{
"type": "theorem",
"title": "Homomorphic mapping of subgroup of domain is subgroup of codomain",
"description": "Homomorphic mapping of subgroup of domain is subgroup of codomain. Inverse mapping of subgroup of codomain is subgroup of domain.",
"uci": "/abstract-algebra/groups/homomorphism/subgroup",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/homomorphism/subgroup.html"
},
{
"type": "theorem",
"title": "Homomorphic mapping and inverse mapping of normal subgroup is normal",
"description": "Homomorphic mapping of normal subgroup is normal in homomorphic mapping of group. Homomorphic inverse mapping of normal subgroup of codomain is normal in domain.",
"uci": "/abstract-algebra/groups/homomorphism/normal-subgroup",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/homomorphism/normal-subgroup.html"
},
{
"type": "theorem",
"title": "First isomorphism theorem",
"description": "Image of homomorphism \u03d5 from G to H is isomorphic to quotient group G/ker(\u03d5).",
"uci": "/abstract-algebra/groups/first-isomorphism-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/first-isomorphism-theorem.html"
},
{
"type": "theorem",
"title": "Correspondence theorem",
"description": "A subgroup of G/N is of the form K/N, where K is a subgroup of G. If K is a subgroup of G, then K/N is a subgroup of G/N.",
"uci": "/abstract-algebra/groups/factor-groups/correspondence-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/factor-groups/correspondence-theorem.html"
},
{
"type": "theorem",
"title": "Normal correspondence theorem",
"description": "A normal subgroup of G/N is of the form K/N, where K is a normal subgroup of G. If K is a normal subgroup of G, then K/N is a normal subgroup of G/N.",
"uci": "/abstract-algebra/groups/factor-groups/normal-correspondence-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/factor-groups/normal-correspondence-theorem.html"
},
{
"type": "theorem",
"title": "Third isomorphism theorem",
"description": "(G/N)/(K/N) is isomorphic to G/K.",
"uci": "/abstract-algebra/groups/third-isomorphism-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/third-isomorphism-theorem.html"
},
{
"type": "def",
"title": "Alternating Group",
"description": "The set of all even permutations is called the alternating group",
"uci": "/abstract-algebra/groups/permutation-groups/alternating-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/permutation-groups/alternating-group.html"
},
{
"type": "theorem",
"title": "Second isomorphism theorem",
"description": "Let S be a subgroup of G and N be a normal subgroup of G. Then SN/N is isomorphic to S/(S\u2229N).",
"uci": "/abstract-algebra/groups/second-isomorphism-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/second-isomorphism-theorem.html"
},
{
"type": "def",
"title": "Semiring",
"description": "A semiring is an algebraic structure similar to a ring, but without the requirement that each element must have an additive inverse.",
"uci": "/abstract-algebra/semiring",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/semiring.html"
},
{
"type": "theoremdef",
"title": "Matrix",
"description": "A matrix is set of numbers arranged in rows and columns.",
"uci": "/linear-algebra/matrices/matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/matrix.html"
},
{
"type": "def",
"title": "Stacking",
"description": "[A|B] is the horizontal stacking of matrices. [A/B] is the vertical stacking of matrices.",
"uci": "/linear-algebra/matrices/stacking/stacking",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/stacking/stacking.html"
},
{
"type": "theorem",
"title": "System of linear equations",
"description": "A system of linear equations is a set of equations which equate linear combinations of variables to a value.",
"uci": "/linear-algebra/system-of-linear-equations/system-of-linear-equations",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/system-of-linear-equations/system-of-linear-equations.html"
},
{
"type": "theorem",
"title": "Product of stacked matrices",
"description": "",
"uci": "/linear-algebra/matrices/stacking/product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/stacking/product.html"
},
{
"type": "theorem",
"title": "Sum of stacked matrices",
"uci": "/linear-algebra/matrices/stacking/sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/stacking/sum.html"
},
{
"type": "theorem",
"title": "Transpose of stacked matrix",
"uci": "/linear-algebra/matrices/stacking/transpose",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/stacking/transpose.html"
},
{
"type": "theorem",
"title": "Matrix multiplication is associative",
"uci": "/linear-algebra/matrices/mult-assoc",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/mult-assoc.html"
},
{
"type": "def",
"title": "Positive definite",
"description": "A real square matrix A is positive definite iff for all non-0 u, u^TAu > 0. A is positive semidefinite iff for all u, u^TAu \u2265 0.",
"keywords": [
"positive",
"negative",
"definite",
"semidefinite",
"PSD",
"PD",
"NSD",
"ND"
],
"uci": "/linear-algebra/matrices/positive-definite",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/positive-definite.html"
},
{
"type": "theorem",
"title": "Sum of positive definite matrices is positive definite",
"uci": "/linear-algebra/matrices/pd-sum-is-pd",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/pd-sum-is-pd.html"
},
{
"type": "def",
"title": "Reduced Row Echelon Form (RREF)",
"uci": "/linear-algebra/matrices/rref",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/rref.html"
},
{
"type": "theorem",
"title": "Rows of RREF are linearly independent",
"description": "If a matrix is in RREF, its non-zero rows are linearly independent.",
"uci": "/linear-algebra/matrices/rref-linindep",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/rref-linindep.html"
},
{
"type": "theorem",
"title": "Matrix multiplication distributes over addition",
"description": "A(B+C) = AB + AC.",
"uci": "/linear-algebra/matrices/distributive",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/distributive.html"
},
{
"type": "theorem",
"title": "c(AB) = (cA)B and (AB)c = A(Bc)",
"uci": "/linear-algebra/matrices/scalar-mult-assoc",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/scalar-mult-assoc.html"
},
{
"type": "def",
"title": "Conjugate Transpose and Hermitian",
"description": "The conjugate transpose of a matrix is the complex conjugate of its transpose. A matrix is defined to be hermitian iff it equals its conjugate transpose.",
"uci": "/linear-algebra/matrices/hermitian",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/hermitian.html"
},
{
"type": "theorem",
"title": "Transpose of product",
"description": "(AB)' = B'A'",
"uci": "/linear-algebra/matrices/transpose-of-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/transpose-of-product.html"
},
{
"type": "theorem",
"title": "Conjugation of matrices is homomorphic",
"uci": "/linear-algebra/matrices/conjugation-is-homomorphic",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/conjugation-is-homomorphic.html"
},
{
"type": "def",
"title": "Submatrix",
"description": "A submatrix of a matrix M is a matrix obtained by removing a few rows and/or columns of M.",
"uci": "/linear-algebra/matrices/submatrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/submatrix.html"
},
{
"type": "def",
"title": "Determinant",
"description": "A determinant is a number associated with a square matrix.",
"uci": "/linear-algebra/matrices/determinants/determinant",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/determinants/determinant.html"
},
{
"type": "theorem",
"title": "Determinant of upper triangular matrix",
"description": "The determinant of an upper triangular matrix is the product of diagonal elements.",
"uci": "/linear-algebra/matrices/determinants/upper-triangular",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/determinants/upper-triangular.html"
},
{
"type": "theorem",
"title": "Swapping last 2 rows of a matrix negates its determinant",
"uci": "/linear-algebra/matrices/determinants/last-2-rows-swap",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/determinants/last-2-rows-swap.html"
},
{
"type": "def",
"title": "Trace of a matrix",
"description": "The trace of a square matrix is the sum of its diagonal entries.",
"uci": "/linear-algebra/matrices/trace",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/trace.html"
},
{
"type": "theorem",
"title": "Matrices over a field form a vector space",
"description": "",
"uci": "/linear-algebra/matrices/vector-space",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/vector-space.html"
},
{
"type": "theoremdef",
"title": "Row space",
"description": "The row space of a matrix is the set of all linear combinations of the rows of the matrix. The row space is a vector space.",
"uci": "/linear-algebra/matrices/row-space",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/row-space.html"
},
{
"type": "theorem",
"title": "Matrices form an inner-product space",
"description": "Let F be a subfield of complex numbers. Matrices over F form an inner-product space, where the inner product is given by tr(A*B).",
"uci": "/linear-algebra/matrices/inner-product-space",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/inner-product-space.html"
},
{
"type": "def",
"title": "Elementary row operation",
"description": "An elementary row operation on a matrix either adds a multiple of a row to another row, multiplies a row by a scalar or swaps two rows.",
"uci": "/linear-algebra/matrices/elementary-rowop",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/elementary-rowop.html"
},
{
"type": "theorem",
"title": "Determinant after elementary row operation",
"description": "Applying an elementary row operation on a matrix multiplies its determinant by a number which depends only on the type of the operation, not on the matrix.",
"uci": "/linear-algebra/matrices/determinants/elementary-rowop",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/determinants/elementary-rowop.html"
},
{
"type": "theorem",
"title": "Determinant of scalar product of matrix",
"description": "|cA| = c^n|A|",
"uci": "/linear-algebra/matrices/determinants/scalar-mult",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/determinants/scalar-mult.html"
},
{
"type": "theorem",
"title": "Elementary row operation on stacked matrix",
"description": "Let f be an elementary row operation. Then f([A|B]) = [f(A)|f(B)].",
"uci": "/linear-algebra/matrices/stacking/elementary-rowop",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/stacking/elementary-rowop.html"
},
{
"type": "theorem",
"title": "Every elementary row operation has a unique inverse",
"uci": "/linear-algebra/matrices/elementary-rowop-inv",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/elementary-rowop-inv.html"
},
{
"type": "theoremdef",
"title": "Row equivalence of matrices",
"description": "Matrices A and B are row equivalent iff B can be obtained from A by applying a finite number of elementary row operations to A.",
"uci": "/linear-algebra/matrices/row-equiv",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/row-equiv.html"
},
{
"type": "theorem",
"title": "Row equivalent matrices have the same row space",
"uci": "/linear-algebra/matrices/row-equiv-matrices-have-same-row-space",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/row-equiv-matrices-have-same-row-space.html"
},
{
"type": "theorem",
"title": "RREF is unique",
"description": "Every matrix is row equivalent to a unique matrix in RREF.",
"uci": "/linear-algebra/matrices/unique-rref",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/unique-rref.html"
},
{
"type": "def",
"title": "Identity matrix",
"uci": "/linear-algebra/matrices/identity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/identity.html"
},
{
"type": "theorem",
"title": "Identity matrix is identity of matrix product",
"description": "The identity matrix is the unique matrix I satisfying (\u2200A, I = IA = A).",
"uci": "/linear-algebra/matrices/identity-condition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/identity-condition.html"
},
{
"type": "theoremdef",
"title": "Inverse of a matrix",
"description": "The inverse of matrix A is a matrix B such that AB = BA = I.",
"uci": "/linear-algebra/matrices/inverse",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/inverse.html"
},
{
"type": "theorem",
"title": "Inverse of product",
"description": "inv(AB) = inv(B)inv(A)",
"uci": "/linear-algebra/matrices/inverse-of-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/inverse-of-product.html"
},
{
"type": "theorem",
"title": "Elementary row operation is matrix pre-multiplication",
"description": "Every elementary row operation has a corresponding invertible matrix R such that the result of applying the operation on a matrix A is RA.",
"uci": "/linear-algebra/matrices/elementary-rowop-matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/elementary-rowop-matrix.html"
},
{
"type": "theorem",
"title": "Row equivalence matrix",
"description": "If A and B are row equivalent, then there exists an invertible matrix R such that B = RA.",
"uci": "/linear-algebra/matrices/row-equiv-matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/row-equiv-matrix.html"
},
{
"type": "theorem",
"title": "Equations with row equivalent matrices have the same solution set",
"description": "If [A|B] is row equivalent to [C|D], then AX=B and CX=D have the same solution set.",
"uci": "/linear-algebra/system-of-linear-equations/row-equiv-have-same-solutions",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/system-of-linear-equations/row-equiv-have-same-solutions.html"
},
{
"type": "theorem",
"title": "Rank of a homogenous system of linear equations",
"description": "If AX = 0 is a system of equations, then rank(A) = n iff X=0 is the only solution.",
"uci": "/linear-algebra/system-of-linear-equations/rank-homogenous",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/system-of-linear-equations/rank-homogenous.html"
},
{
"type": "def",
"title": "Rank of a matrix",
"description": "The rank of a matrix is the number of non-zero rows in the RREF of the matrix.",
"uci": "/linear-algebra/matrices/rank",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/rank.html"
},
{
"type": "theoremdef",
"title": "Basis of a vector space",
"description": "If a set of vectors B is linearly independent and spans a vector space V, then B is a basis of V. All bases of a vector space have the same size.",
"uci": "/linear-algebra/vector-spaces/basis/basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/basis.html"
},
{
"type": "theorem",
"title": "Linearly independent set is smaller than a span",
"description": "The size of every finite linearly independent subset of a vector space is less than or equal to the size of every spanning set of that vector space.",
"uci": "/linear-algebra/vector-spaces/linindep-is-smaller-than-span",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/linindep-is-smaller-than-span.html"
},
{
"type": "theorem",
"title": "Homogeneous linear equations with more variables than equations",
"description": "If AX = 0 is a system of linear equations with more variables than equations, then there exists a non-trivial solution.",
"uci": "/linear-algebra/system-of-linear-equations/more-variables-than-equations",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/system-of-linear-equations/more-variables-than-equations.html"
},
{
"type": "theorem",
"title": "Vector matroid",
"description": "A finite set of vectors from a vector space form a matroid under linear independence.",
"keywords": [
"vector matroid",
"matric matroid"
],
"uci": "/matroids/examples/vector",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/examples/vector.html"
},
{
"type": "theorem",
"title": "A set of dim(V) linearly independent vectors is a basis",
"uci": "/linear-algebra/vector-spaces/basis/n-linindep-is-basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/n-linindep-is-basis.html"
},
{
"type": "theorem",
"title": "Spanning set of size dim(V) is a basis",
"uci": "/linear-algebra/vector-spaces/basis/n-span-is-basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/n-span-is-basis.html"
},
{
"type": "theorem",
"title": "A matrix is full-rank iff its rows are linearly independent",
"uci": "/linear-algebra/matrices/full-rank-linindep",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/full-rank-linindep.html"
},
{
"type": "theorem",
"title": "Minimally spanning iff basis",
"description": "A finite set of vectors S minimally spans V iff S is a basis.",
"uci": "/linear-algebra/vector-spaces/basis/minimal-span-is-basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/minimal-span-is-basis.html"
},
{
"type": "theorem",
"title": "Preserving a basis by replacing a vector",
"uci": "/linear-algebra/vector-spaces/basis/replace-vector",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/replace-vector.html"
},
{
"type": "theorem",
"title": "Basis of F^n",
"uci": "/linear-algebra/vector-spaces/basis/basis-of-fn",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/basis-of-fn.html"
},
{
"type": "theorem",
"title": "Matrix of linear transformation",
"description": "Every linear transformation from F^m to F^n can be expressed as a matrix pre-multiplication. Conversely, a pre-multiplication by a matrix forms a linear transformation.",
"uci": "/linear-algebra/linear-transformation/matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/matrix.html"
},
{
"type": "theoremdef",
"title": "Coordinatization over a basis",
"description": "Let B be a basis of vector space V. Then every vector in V can be expressed uniquely as a finite linear combination of vectors in B. The coefficients of the linear combination are called the coordinates of that vector.",
"uci": "/linear-algebra/vector-spaces/basis/coordinatization",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/coordinatization.html"
},
{
"type": "theoremdef",
"title": "Basis changer",
"description": "A basis changer is a bijection which maps coordinates of one basis to coorindates of another basis.",
"uci": "/linear-algebra/vector-spaces/basis/basis-change",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/basis-change.html"
},
{
"type": "theorem",
"title": "Basis change is an isomorphic linear transformation",
"uci": "/linear-algebra/linear-transformation/basis-change",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/basis-change.html"
},
{
"type": "theorem",
"title": "Vector spaces are isomorphic iff their dimensions are same",
"description": "Two vector spaces are isomorphic iff they have the same dimension.",
"uci": "/linear-algebra/linear-transformation/isomorphic-dimension",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/isomorphic-dimension.html"
},
{
"type": "theorem",
"title": "Canonical decomposition of a linear transformation",
"description": "Let T be a linear transformation from U to V. Then T = T3.T2.T1 where T1: U to F^dim(U), T2: F^dim(U) to F^dim(V), T3: F^dim(V) to V are linear transformations. This is called the canonical decomposition of T.",
"uci": "/linear-algebra/linear-transformation/canonical-decomposition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/canonical-decomposition.html"
},
{
"type": "theoremdef",
"title": "Eigenvalues and Eigenvectors",
"description": "Let T be a linear transformation. If T(x) = kx is satisfied for some k and some x, then k is an eigenvalue and x is an eigenvector.",
"keywords": [
"eigenvalue",
"eigenvector",
"eigenpair"
],
"uci": "/linear-algebra/eigenvectors/eigenvector",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/eigenvector.html"
},
{
"type": "theorem",
"title": "All eigenvalues of a hermitian matrix are real",
"uci": "/linear-algebra/eigenvectors/hermitian-real",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/hermitian-real.html"
},
{
"type": "theorem",
"title": "All eigenvalues of a symmetric operator are real",
"uci": "/linear-algebra/eigenvectors/symmetric-real",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/symmetric-real.html"
},
{
"type": "theorem",
"title": "Real matrix with real eigenvalues has real eigenvectors",
"description": "If a matrix A has only real entries and \u03bb is a real eigenvalue of A, then A has real eigenvectors corresponding to \u03bb.",
"uci": "/linear-algebra/eigenvectors/real-matrix-with-real-eigenvalue-has-real-eigenvectors",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/real-matrix-with-real-eigenvalue-has-real-eigenvectors.html"
},
{
"type": "theoremdef",
"title": "Eigenspace",
"description": "Let A be a matrix and \u03bb be an eigenvalue of A. Then E(\u03bb) is the vector space of all solutions to Ax = \u03bbx.",
"uci": "/linear-algebra/eigenvectors/eigenspace",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/eigenspace.html"
},
{
"type": "theorem",
"title": "Eigenvectors of distinct eigenvalues are linearly independent",
"description": "In all vectors in a set of eigenvectors correspond to different eigenvalues, then the set is linearly independent.",
"uci": "/linear-algebra/eigenvectors/distinct-eigenvalue-linindep",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/distinct-eigenvalue-linindep.html"
},
{
"type": "theorem",
"title": "Diagonalization",
"description": "Let A be a square matrix. Let P be the matrix whose columns are eigenvectors of A. Then AP = PD, where D is a diagonal matrix.",
"uci": "/linear-algebra/eigenvectors/diagonalization",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/diagonalization.html"
},
{
"type": "theorem",
"title": "Symmetric operator iff hermitian",
"description": "Let L: V to V be a linear transformation and A be the square matrix associated with L. Then L is symmetric iff A is hermitian. Also, if T(u) = Au, then A is hermitian iff T is a symmetric operator.",
"uci": "/linear-algebra/linear-transformation/symmetric-operator-matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/symmetric-operator-matrix.html"
},
{
"type": "theorem",
"title": "Maximally linearly independent iff basis",
"description": "A finite set is maximally linearly independent iff it is a basis.",
"uci": "/linear-algebra/vector-spaces/basis/maximal-linindep-is-basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/maximal-linindep-is-basis.html"
},
{
"type": "theorem",
"title": "Linearly independent set can be expanded into a basis",
"description": "If a set of vectors is linearly independent, a finite number of vectors can be added to it to make it a basis if the vector space has a finite-sized basis.",
"uci": "/linear-algebra/vector-spaces/basis/expand-linindep-to-basis",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/vector-spaces/basis/expand-linindep-to-basis.html"
},
{
"type": "theorem",
"title": "Basis of range of linear transformation",
"description": "If P is a basis of the kernel and P union Q is a basis of U, then T(Q) is a basis of T(U).",
"uci": "/linear-algebra/linear-transformation/basis-of-range",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/basis-of-range.html"
},
{
"type": "theorem",
"title": "Full-rank square matrix in RREF is the identity matrix",
"description": "Let A be an n by n matrix. If A is in RREF and all rows of A are non-zero, then A is the identity matrix.",
"uci": "/linear-algebra/matrices/full-rank-square-rref-is-identity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/full-rank-square-rref-is-identity.html"
},
{
"type": "theorem",
"title": "A matrix is full-rank iff its determinant is non-0",
"uci": "/linear-algebra/matrices/determinants/rank",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/determinants/rank.html"
},
{
"type": "theoremdef",
"title": "Characteristic polynomial of a matrix",
"description": "The characteristic polynomial of a matrix A is |xI - A|. Its roots are the eigenvalues of A.",
"uci": "/linear-algebra/eigenvectors/char-poly",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/char-poly.html"
},
{
"type": "theorem",
"title": "Degree and monicness of a characteristic polynomial",
"description": "Let A be an n by n matrix. The characteristic polynomial of A is a monic polynomial of degree n.",
"uci": "/linear-algebra/eigenvectors/char-poly-degree-monic",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/char-poly-degree-monic.html"
},
{
"type": "theorem",
"title": "Full-rank square matrix is invertible",
"description": "Let A be an n by n matrix. Then rank(A) = n iff A has an inverse.",
"uci": "/linear-algebra/matrices/full-rank-inv",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/full-rank-inv.html"
},
{
"type": "theorem",
"title": "AB = I implies BA = I",
"uci": "/linear-algebra/matrices/product-equals-identity-implies-invertible",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/product-equals-identity-implies-invertible.html"
},
{
"type": "theorem",
"title": "Determinant of product is product of determinants",
"description": "|AB| = |A||B|",
"uci": "/linear-algebra/matrices/determinants/product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/determinants/product.html"
},
{
"type": "theorem",
"title": "Every complex matrix has an eigenvalue",
"uci": "/linear-algebra/eigenvectors/every-complex-matrix-has-eigenvalue",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/every-complex-matrix-has-eigenvalue.html"
},
{
"type": "theorem",
"title": "Symmetric operator on V has a basis of orthonormal eigenvectors",
"description": "Let L be a symmetric operator on V, a vector space over the complex numbers. Then there is a basis of V consisting of orthonormal eigenvectors of L.",
"uci": "/linear-algebra/eigenvectors/symmetric-operator-has-n-ortho-eigenvectors",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/symmetric-operator-has-n-ortho-eigenvectors.html"
},
{
"type": "theoremdef",
"title": "Orthogonal matrix",
"description": "A matrix A is orthogonal iff A'A = I. Equivalently, A is orthogonal iff rows of A are orthonormal.",
"uci": "/linear-algebra/matrices/orthogonal",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/orthogonal.html"
},
{
"type": "theorem",
"title": "Orthonormal basis change matrix",
"description": "Let U and V be 2 orthonormal bases. Then the basis change matrix from U to V is orthogonal.",
"uci": "/linear-algebra/inner-product-spaces/basis-changer",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/inner-product-spaces/basis-changer.html"
},
{
"type": "theorem",
"title": "Orthogonally diagonalizable iff hermitian",
"description": "A matrix A is said to be orthogonally diagonalizable iff it can be expressed as PDP*, where P is orthogonal. Then A is orthogonally diagonalizable iff A = A*.",
"uci": "/linear-algebra/eigenvectors/ortho-diag",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/ortho-diag.html"
},
{
"type": "theorem",
"title": "Bounding matrix quadratic form using eigenvalues",
"description": "Let A be a real symmetric matrix. Then u^TAu/\u2225u\u2225^2 lies between the minimum and maximum eigenvalues",
"uci": "/linear-algebra/matrices/bounding-quadratic-form-using-eigenvalues",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/bounding-quadratic-form-using-eigenvalues.html"
},
{
"type": "theorem",
"title": "Positive definite iff eigenvalues are positive",
"description": "A matrix A is positive definite iff all its eigenvalues are positive. It is positive semidefinite iff all its eigenvalues are non-negative.",
"uci": "/linear-algebra/matrices/pd-iff-pos-eigens",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/pd-iff-pos-eigens.html"
},
{
"type": "theorem",
"title": "Matrix of orthonormal basis change",
"description": "Let P and Q be orthonormal bases of U and V respectively. Then the transformation matrix of the basis-changer from P to Q is orthogonal.",
"uci": "/linear-algebra/linear-transformation/matrix-of-orthonormal-basis-change",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/linear-transformation/matrix-of-orthonormal-basis-change.html"
},
{
"type": "theorem",
"title": "A is diagonalizable iff there are n linearly independent eigenvectors",
"description": "Let A be an n by n matrix. Then A is diagonalizable iff A has n linearly independent eigenvectors.",
"uci": "/linear-algebra/eigenvectors/diag-linindep",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/diag-linindep.html"
},
{
"type": "theorem",
"title": "RREF([A|I]) = [I|inv(A)] iff A is invertible",
"description": "This is an algorithm for finding the inverse of a matrix by calculating RREF.",
"uci": "/linear-algebra/matrices/rref-inv",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/rref-inv.html"
},
{
"type": "theorem",
"title": "Eigenpair of affine transformation",
"description": "If (\u03bb, v) is an eigenpair of matrix A, then (a\u03bb+b, v) is an eigenpair of aA+bI.",
"uci": "/linear-algebra/eigenvectors/affine",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/affine.html"
},
{
"type": "theorem",
"title": "Bound on eigenvalues of sum of matrices",
"uci": "/linear-algebra/eigenvectors/sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/sum.html"
},
{
"type": "theorem",
"title": "Eigenpair of power of a matrix",
"description": "If (\u03bb, v) is an eigenpair of matrix A, then (\u03bb^k, v) is an eigenpair of A^k.",
"uci": "/linear-algebra/eigenvectors/power",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/eigenvectors/power.html"
},
{
"type": "theorem",
"title": "Square matrices form a (semi)ring",
"uci": "/linear-algebra/matrices/semiring",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/semiring.html"
},
{
"type": "theorem",
"title": "Binomial theorem",
"description": "(a+b)^n = sum(i from 0 to n, C(n,i)*a^(n-i)*b^i).",
"uci": "/combinatorics/bin-coeff/binomial-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/binomial-theorem.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Sum",
"description": "sum(i from 0 to n, C(n, i)) = 2^n",
"uci": "/combinatorics/bin-coeff/sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/sum.html"
},
{
"type": "theorem",
"title": "Binomial coefficient: Sum 1",
"uci": "/combinatorics/bin-coeff/sum-1",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/combinatorics/bin-coeff/sum-1.html"
},
{
"type": "theorem",
"title": "gcd(a, b) = gcd(a-b, b)",
"keywords": [
"gcd",
"subtraction"
],
"uci": "/number-theory/gcd/gcd-subtraction",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/gcd/gcd-subtraction.html"
},
{
"type": "theorem",
"title": "Every number has a prime factorization",
"uci": "/number-theory/prime-factorization/every-number-has-prime-factorization",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/every-number-has-prime-factorization.html"
},
{
"type": "def",
"title": "Modular Equivalence",
"description": "a is equivalent to b mod n iff n divides (a-b).",
"uci": "/number-theory/modular-equivalence",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/modular-equivalence.html"
},
{
"type": "theorem",
"title": "Modular multiplication",
"description": "a1 \u2261 b1 and a2 \u2261 b2 implies a1a2 \u2261 b1b2",
"uci": "/number-theory/mod-mult",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/mod-mult.html"
},
{
"type": "theorem",
"title": "Modular addition",
"description": "a1 \u2261 b1 and a2 \u2261 b2 implies a1+a2 \u2261 b1+b2",
"uci": "/number-theory/mod-add",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/mod-add.html"
},
{
"type": "def",
"title": "Coprime",
"description": "Two numbers are coprime iff 1 is the only positive number which divides both of them.",
"uci": "/number-theory/coprime",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/coprime.html"
},
{
"type": "def",
"title": "Euler's Totient Function",
"description": "Euler's totient function \u03d5(n) is the number of numbers smaller than n and coprime to it.",
"uci": "/number-theory/eulers-totient-function",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/eulers-totient-function.html"
},
{
"type": "theorem",
"title": "Integer Division Theorem",
"keywords": [
"euclid",
"division"
],
"description": "Let a and b be integers, with b > 0. Then there exist unique integers q and r such that a = b*q + r and 0 \u2264 r < b.",
"uci": "/number-theory/integer-division-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/integer-division-theorem.html"
},
{
"type": "theorem",
"title": "Every ideal of Z is a principal ideal",
"uci": "/abstract-algebra/rings/ideal-of-z-is-principal",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/ideal-of-z-is-principal.html"
},
{
"type": "theorem",
"title": "Zn is a ring",
"description": "The set of integers modulo n is a ring.",
"uci": "/abstract-algebra/rings/zn-is-ring",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/zn-is-ring.html"
},
{
"type": "theorem",
"title": "Order of cyclic subgroup is order of generator",
"description": "Let g be an element of the group G. Then |<g>| = order(g).",
"uci": "/abstract-algebra/groups/cyclic-groups/order-of-cyclic-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/order-of-cyclic-group.html"
},
{
"type": "theorem",
"title": "Order of element divides order of group",
"uci": "/abstract-algebra/groups/order-of-element-divides-order-of-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/order-of-element-divides-order-of-group.html"
},
{
"type": "theorem",
"title": "Group of prime order is cyclic",
"uci": "/abstract-algebra/groups/cyclic-groups/group-of-prime-order-is-cyclic",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/group-of-prime-order-is-cyclic.html"
},
{
"type": "theorem",
"title": "Group element to the power group size equals identity",
"description": "a^|G| = e",
"uci": "/abstract-algebra/groups/group-elem-to-the-power-group-size-equals-identity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/group-elem-to-the-power-group-size-equals-identity.html"
},
{
"type": "theorem",
"title": "GCD is the smallest Linear Combination",
"description": "The gcd of a set of numbers is their smallest positive linear combination.",
"uci": "/number-theory/gcd/gcd-is-min-lincomb",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/gcd/gcd-is-min-lincomb.html"
},
{
"type": "theorem",
"title": "Subgroups of a cyclic group",
"description": "For an infinite-order cyclic group <a>, subgroups are <a^k> for all k. For a cyclic group <a> of order n, subgroups are <a^k> for all divisors k of n.",
"uci": "/abstract-algebra/groups/cyclic-groups/subgroups-of-cyclic-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/subgroups-of-cyclic-group.html"
},
{
"type": "theorem",
"title": "Common divisor divides GCD",
"description": "Commmon divisor of a set of numbers divides their GCD.",
"uci": "/number-theory/gcd/common-divisor-divides-gcd",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/gcd/common-divisor-divides-gcd.html"
},
{
"type": "theorem",
"title": "gcd(a1/d, a2/d, ..., an/d) = gcd(a1, a_2, ..., an)/d",
"uci": "/number-theory/gcd/gcd-divide",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/gcd/gcd-divide.html"
},
{
"type": "theorem",
"title": "A polynomial in rationals is a rational times a polynomial in integers",
"uci": "/polynomials/rational-to-int",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/rational-to-int.html"
},
{
"type": "theorem",
"title": "GCD partitioning of Zn",
"description": "Zn equals union of dZ(n/d)* for all divisors d of n.",
"uci": "/number-theory/gcd-partitioning-of-zn",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/gcd-partitioning-of-zn.html"
},
{
"type": "theorem",
"title": "gcd is associative",
"description": "gcd(a1, a2, ..., am, b1, b2, ... bn) = gcd(gcd(a1, a2, ..., am), b1, b2, ..., bm)",
"uci": "/number-theory/gcd/associativity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/gcd/associativity.html"
},
{
"type": "theorem",
"title": "If x divides ab and x is coprime to a, then x divides b",
"description": "If a number divides the product of two numbers and is coprime to the first number in the product, then it must divide the second number in the product.",
"uci": "/number-theory/if-coprime-to-first-then-divides-second",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/if-coprime-to-first-then-divides-second.html"
},
{
"type": "theorem",
"title": "Order of elements in cyclic group",
"description": "Order of elements in a cyclic group.",
"uci": "/abstract-algebra/groups/cyclic-groups/order-of-elements-in-cyclic-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/order-of-elements-in-cyclic-group.html"
},
{
"type": "theorem",
"title": "A cyclic group of order n has \u03d5(n) generators",
"uci": "/abstract-algebra/groups/cyclic-groups/cyclic-group-has-phi-generators",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/cyclic-groups/cyclic-group-has-phi-generators.html"
},
{
"type": "theorem",
"title": "Euclid's lemma",
"description": "If a prime divides the product of two numbers, it must divide at least one of those numbers.",
"uci": "/number-theory/euclids-lemma",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/euclids-lemma.html"
},
{
"type": "theorem",
"title": "Zp is an integral domain",
"description": "If p is prime, Zp is an integral domain",
"uci": "/abstract-algebra/rings/zp-is-intdom",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/zp-is-intdom.html"
},
{
"type": "theorem",
"title": "Gauss' Lemma",
"description": "If a polynomial in Z[x] has a factor in Q[x], it also has a factor in Z[x] of the same degree.",
"uci": "/polynomials/gauss-lemma",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/gauss-lemma.html"
},
{
"type": "theorem",
"title": "Eisenstein's criterion",
"description": "If f(x) is in Z[x] and p is prime and deg(f) = n and p divides all fi except fn and p^2 does not divide f0, then f is irreducible over Q[x].",
"uci": "/polynomials/eisensteins-criterion",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/polynomials/eisensteins-criterion.html"
},
{
"type": "theorem",
"title": "Fundamental Theorem of Arithmetic",
"keywords": [
"prime",
"factor",
"factorize",
"factorization"
],
"description": "An integer can be written as a product of primes in a unique way.",
"uci": "/number-theory/prime-factorization/fundamental-theorem-of-arithmetic",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/fundamental-theorem-of-arithmetic.html"
},
{
"type": "def",
"title": "Prime Factorization Exponent List (PFEL)",
"description": "PFEL of a number is the list of exponents in the prime factorization of that number.",
"uci": "/number-theory/prime-factorization/pfel",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/pfel.html"
},
{
"type": "theorem",
"title": "PFEL of ratio is difference of PFEL",
"uci": "/number-theory/prime-factorization/pfel-of-ratio-is-difference-of-pfel",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/pfel-of-ratio-is-difference-of-pfel.html"
},
{
"type": "theorem",
"title": "PFEL of product is sum of PFEL",
"uci": "/number-theory/prime-factorization/pfel-of-product-is-sum-of-pfel",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/pfel-of-product-is-sum-of-pfel.html"
},
{
"type": "theorem",
"title": "Divisible iff PFEL is less than or equal",
"description": "a divides b iff PFEL(a) \u2264 PFEL(b).",
"uci": "/number-theory/prime-factorization/divisible-iff-pfel-less-than",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/divisible-iff-pfel-less-than.html"
},
{
"type": "theorem",
"title": "PFEL of lcm is max of PFEL",
"uci": "/number-theory/prime-factorization/pfel-of-lcm-is-max-of-pfel",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/pfel-of-lcm-is-max-of-pfel.html"
},
{
"type": "theorem",
"title": "PFEL of gcd is min of PFEL",
"uci": "/number-theory/prime-factorization/pfel-of-gcd-is-min-of-pfel",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/prime-factorization/pfel-of-gcd-is-min-of-pfel.html"
},
{
"type": "theorem",
"title": "ab is coprime to x iff a and b are coprime to x",
"uci": "/number-theory/ab-coprime-to-x-iff-a-and-b-coprime-to-x",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/ab-coprime-to-x-iff-a-and-b-coprime-to-x.html"
},
{
"type": "theorem",
"title": "Multiplication permutes Zn*",
"description": "Multiplying all elements of Zn* by a number coprime to n returns a permutation of Zn*",
"uci": "/number-theory/multiplication-permutes-znstar",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/multiplication-permutes-znstar.html"
},
{
"type": "theorem",
"title": "LCM divides common multiple",
"description": "lcm(a, b) divides every common multiple of a and b.",
"uci": "/number-theory/lcm-divides-common-multiple",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/lcm-divides-common-multiple.html"
},
{
"type": "theorem",
"title": "\u03d5 is multiplicative",
"description": "Euler's totient function is multiplicative. This means that if a and b are coprime, then \u03d5(ab) = \u03d5(a)\u03d5(b).",
"uci": "/number-theory/phi-is-multiplicative",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/phi-is-multiplicative.html"
},
{
"type": "theorem",
"title": "Product of coprime divisors is divisor",
"description": "If a|x and b|x and gcd(a, b) = 1, then ab|x.",
"uci": "/number-theory/product-of-coprime-divisors-is-divisor",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/product-of-coprime-divisors-is-divisor.html"
},
{
"type": "theorem",
"title": "GCD times LCM equals product",
"description": "gcd(a, b) * lcm(a, b) = a * b",
"uci": "/number-theory/gcd-times-lcm-equals-product",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/gcd-times-lcm-equals-product.html"
},
{
"type": "theorem",
"title": "Zm \u00d7 Zn is isomorphic to Zmn iff m and n are coprime",
"uci": "/abstract-algebra/groups/isomorphism/zm-cross-zn-isomorphic-to-zmn",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/isomorphism/zm-cross-zn-isomorphic-to-zmn.html"
},
{
"type": "theorem",
"title": "Sum of \u03d5 of divisors",
"description": "The sum of \u03d5(d) for all divisors d of n equals n.",
"keywords": [
"phi",
"totient",
"ETF"
],
"uci": "/number-theory/sum-of-phi-of-divisors",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/sum-of-phi-of-divisors.html"
},
{
"type": "theorem",
"title": "Existence of Modular Inverse",
"description": "Modular inverse of a mod n exists iff gcd(a, n) = 1",
"uci": "/number-theory/mod-inv-existence",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/mod-inv-existence.html"
},
{
"type": "theorem",
"title": "Zp is a field",
"description": "If p is prime, Zp is a field",
"uci": "/abstract-algebra/rings/zp-is-field",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/rings/zp-is-field.html"
},
{
"type": "theorem",
"title": "Zn* is a group",
"description": "The set of integers coprime to n is a group under multiplication mod n",
"uci": "/abstract-algebra/groups/znstar-is-a-group",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/abstract-algebra/groups/znstar-is-a-group.html"
},
{
"type": "theorem",
"title": "Euler's Theorem",
"description": "If a and n are coprime, then a^phi(n) \u2261 1 (mod n), where phi is Euler's Totient Function.",
"uci": "/number-theory/eulers-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/eulers-theorem.html"
},
{
"type": "theorem",
"title": "Chinese remainder theorem",
"description": "Helps find x such that x % m = a and x % n = b.",
"uci": "/number-theory/chinese-remainder-theorem",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/number-theory/chinese-remainder-theorem.html"
},
{
"type": "theorem",
"title": "Subset-sum is NP-complete",
"uci": "/complexity/np-completeness/subset-sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/complexity/np-completeness/subset-sum.html"
},
{
"type": "theorem",
"title": "Partition problem is NP-complete",
"uci": "/complexity/np-completeness/partition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/complexity/np-completeness/partition.html"
},
{
"type": "theorem",
"title": "1BP is (1.5-\u03b5)-inapprox",
"description": "It is NP-complete to decide if a set of items can be packed into 2 bins. Consequently, there is no (1.5-\u03b5)-approx algorithm for 1BP unless P=NP.",
"keywords": [
"inapproximability",
"hardness"
],
"uci": "/packing/1d/1.5-inapprox",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/1.5-inapprox.html"
},
{
"type": "theorem",
"title": "Linear programming: Ellipsoid method",
"description": "In linear programming, the optimization problem is to find a point with optimal value that satisfies a set of constraints. In the separation problem, given a point, we have to find out if it satisfies all the constraints, and if it doesn't, find a violated constraint. It can be proven that a polynomial time algorithm for the separation problem can be used to solve the optimization problem in polynomial time via the Ellipsoid algorithm.",
"keywords": [
"ellipsoid",
"khachiyan"
],
"uci": "/optimization/linear-prog/ellipsoid",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/linear-prog/ellipsoid.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Linear programming: rank lemma",
"description": "For an extreme-point solution, the maximum number of linearly independent tight constraints equals the number of non-zero variables.",
"uci": "/optimization/linear-prog/rank-lemma",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/linear-prog/rank-lemma.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "min linear over sum=1 constraint",
"uci": "/optimization/sum-1",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/sum-1.html"
},
{
"type": "def",
"title": "Optimization: Dual and Lagrangian ",
"uci": "/optimization/dual",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/dual.html"
},
{
"type": "theorem",
"title": "Dual of a linear program",
"description": "The dual of a linear program is another linear program obtained by applying a transformation to the original linear program.",
"uci": "/optimization/linear-prog/dual",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/linear-prog/dual.html"
},
{
"type": "theorem",
"title": "Bin packing: dual of the density-restricted config LP",
"uci": "/packing/config-lp/dr-config-lp-dual",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/dr-config-lp-dual.html"
},
{
"type": "theorem",
"title": "Bin packing: dual of config LP",
"uci": "/packing/config-lp/dual",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/dual.html"
},
{
"type": "theorem",
"title": "Bin packing: config LP dual solution increases with size",
"description": "Let y be the optimal solution to the dual of the config LP of a bin packing instance. If item i is at least as large as item j then y_i is at least as large as y_j.",
"uci": "/packing/config-lp/sol-prop-size",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/sol-prop-size.html"
},
{
"type": "theorem",
"title": "Linear programming: strong duality",
"description": "The optimal objective value of a linear program and its dual are equal.",
"uci": "/optimization/linear-prog/strong-duality",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/linear-prog/strong-duality.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Optimization: weak duality",
"description": "The optimal objective value of a maximization problem at most the optimal objective value of its dual.",
"uci": "/optimization/weak-duality",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/weak-duality.html"
},
{
"type": "theorem",
"title": "Linear programming: weak duality",
"description": "The optimal objective value of a maximization linear program is at most the optimal objective value of its dual.",
"uci": "/optimization/linear-prog/weak-duality",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/linear-prog/weak-duality.html"
},
{
"type": "theorem",
"title": "Minimize maximum coordinate over hyperplane",
"description": "Consider the problem of minimizing max(x) where a^Tx = b. Here a is a vector with non-negative coordinates and max(x) is the maximum coordinate of x. Then the optimal solution is where each coordinate is b/sum(a).",
"uci": "/optimization/min-max-coord",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/min-max-coord.html"
},
{
"type": "def",
"title": "Cone",
"description": "A set S is a cone if for any non-negative \u03b1, x \u2208 S \u27f9 \u03b1x \u2208 S.",
"uci": "/convexity/cone",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/cone.html"
},
{
"type": "def",
"title": "Convex combination and convex hull",
"uci": "/convexity/convex-combination",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/convex-combination.html"
},
{
"type": "def",
"title": "Vertex of a set",
"keywords": [
"vertices"
],
"uci": "/convexity/vertex",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/vertex.html"
},
{
"type": "theorem",
"title": "Transitivity of convexity",
"description": "If x is a convex combination of set Y and each y_i \u2208 Y is a convex combination of Z_i, then x is a convex combination of Z_1 \u222a Z_2 \u222a ...",
"uci": "/convexity/transitivity",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/transitivity.html"
},
{
"type": "def",
"title": "Convex set",
"description": "A set S in the vector space V is convex iff (x \u2208 S and y \u2208 S and t \u2208 [0, 1]) implies (1-t)x + ty \u2208 S.",
"uci": "/convexity/convex-set",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/convex-set.html"
},
{
"type": "theoremdef",
"title": "Polyhedral set",
"description": "A set defined as the intersection of halfspaces is a polyhedral set.",
"keywords": [
"polyhedron",
"polyhedral set",
"polyhedral cone",
"standard form"
],
"uci": "/convexity/polyhedra/polyhedron",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/polyhedron.html"
},
{
"type": "def",
"title": "Basic feasible solutions",
"description": "Let P = {x: Ax \u2264 b, Cx = d} be a polyhedron in R^n. A point x in P is called a basic feasible solution of P iff at least n linearly independent constraints are tight at x.",
"keywords": [
"bfs",
"basic solution",
"degenerate",
"degeneracy"
],
"uci": "/convexity/polyhedra/bfs",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/bfs.html"
},
{
"type": "theorem",
"title": "BFS is vertex",
"description": "A basic feasible solution of a polyhedron is also a vertex of the polyhedron.",
"uci": "/convexity/polyhedra/bfs-is-vertex",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/bfs-is-vertex.html"
},
{
"type": "theorem",
"title": "Condition for existence of BFS in a polyhedron",
"description": "For a non-empty polyhedron P, a BFS exists in P iff there is no line in P iff the constraint matrix has full rank.",
"uci": "/convexity/polyhedra/bfs-existence",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/bfs-existence.html"
},
{
"type": "theorem",
"title": "Point in polytope is convex combination of BFS",
"description": "Let P be a polyhedron that doesn't contain a ray. Then every point in P can be expressed as a convex combination of basic feasible solutions of P.",
"uci": "/convexity/polyhedra/bounded-repr",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/bounded-repr.html"
},
{
"type": "def",
"title": "Extreme point of a convex set",
"description": "x is an extreme point of a set S iff x \u2208 S and x cannot be represented as a convex combination of a finite number of elements of S.",
"uci": "/convexity/extreme-point",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/extreme-point.html"
},
{
"type": "theorem",
"title": "Extreme point iff BFS",
"description": "x is an extreme point of polyhedron P iff x is a BFS of P.",
"uci": "/convexity/polyhedra/extreme-point-iff-bfs",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/extreme-point-iff-bfs.html"
},
{
"type": "theorem",
"title": "Vertex implies extreme point",
"uci": "/convexity/vertex-implies-extreme-point",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/vertex-implies-extreme-point.html"
},
{
"type": "theorem",
"title": "BFS iff vertex iff extreme point",
"description": "For a polyhedron, the set of basic feasible solutions is the same as the set of vertices and is the same as the set of extreme points.",
"uci": "/convexity/polyhedra/bfs-iff-vertex-iff-extreme-point",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/bfs-iff-vertex-iff-extreme-point.html"
},
{
"type": "theorem",
"title": "Condition for a point to be extreme",
"description": "x is a non-extreme point of S iff there is a non-zero vector y such that x+y \u2208 S and x-y \u2208 S.",
"uci": "/convexity/extreme-point-condition",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/extreme-point-condition.html"
},
{
"type": "def",
"title": "Direction of a convex set",
"description": "d is a direction of a convex set S iff \u2200 x \u2208 S, {x + \u03bbd: \u03bb \u2265 0} \u2286 S.",
"uci": "/convexity/direction",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/direction.html"
},
{
"type": "theorem",
"title": "Recession cone of a polyhedron",
"uci": "/convexity/polyhedra/recession-cone",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/recession-cone.html"
},
{
"type": "def",
"title": "Extreme directions of a convex set",
"description": "d is an extreme direction of a convex set S iff d cannot be written as a positive linear combination of two non-collinear directions of S.",
"uci": "/convexity/extreme-direction",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/extreme-direction.html"
},
{
"type": "theorem",
"title": "Extreme directions of polyhedron in positive orthant",
"description": "Let P be a polyhedron in the positive orthant. Then the normalized extreme directions of P are the extreme points of another polytope.",
"uci": "/convexity/polyhedra/orth-extr-dir",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/orth-extr-dir.html"
},
{
"type": "theorem",
"title": "Representing a point in polyhedron in positive orthant",
"description": "Let P be a non-empty polyhedron contained in the positive orthant of R^n. Then any point x \u2208 P can be represented as a convex combination of the basic feasible solutions of P plus a non-negative combination of the extreme directions of P.",
"uci": "/convexity/polyhedra/orth-repr",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/orth-repr.html"
},
{
"type": "theorem",
"title": "LP in orthant is optimized at BFS",
"description": "Let P be the polytope of a linear program that lies in the positive orthant. Then either P is unbounded or has an optimal solution at a BFS of P.",
"uci": "/convexity/polyhedra/orth-lp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/convexity/polyhedra/orth-lp.html"
},
{
"type": "def",
"title": "Probability",
"description": "Definition of some basic concents in probability theory: events, sample space, probability space, probability measure.",
"keywords": [
"event",
"sample space",
"sigma algebra",
"\u03c3-algebra",
"probability",
"probability measure",
"probability space"
],
"uci": "/probability/prob-and-events/probability",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/prob-and-events/probability.html"
},
{
"type": "theoremdef",
"title": "Conditional probability",
"description": "The probability of event A conditioned on event B is denoted as P(A|B).",
"uci": "/probability/prob-and-events/cond-prob",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/prob-and-events/cond-prob.html",
"status": "incomplete"
},
{
"type": "def",
"title": "Independence of events",
"description": "A and B are independent iff P(A\u2229B) = P(A)P(B).",
"uci": "/probability/prob-and-events/ind-events",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/prob-and-events/ind-events.html"
},
{
"type": "theorem",
"title": "Independence of composite events",
"description": "Suppose events A1 and A2 are independent of event B. If A1 and A2 are disjoint, then A1\u22c3A2 is independent of B. If A1 \u2286 A2, then A2 - A1 is independent of B.",
"uci": "/probability/prob-and-events/ind-of-comp-events",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/prob-and-events/ind-of-comp-events.html"
},
{
"type": "theoremdef",
"title": "Random variable",
"description": "A random variable is a measurable function that maps each element of the sample space to an element in some set.",
"uci": "/probability/rand-vars/rand-var",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/rand-var.html"
},
{
"type": "def",
"title": "Markov chain",
"uci": "/probability/markov-chains/markov-chain",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/markov-chain.html"
},
{
"type": "def",
"title": "Markov chains: long run proportion of a state",
"description": "The long run proportion of a state in a markov chain is the proportion of time spent in that state.",
"uci": "/probability/markov-chains/long-run-prop",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/long-run-prop.html"
},
{
"type": "def",
"title": "Markov chains: recurrent states",
"description": "A state is recurrent iff the probability of returning to it is 1.",
"uci": "/probability/markov-chains/recurrence",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/recurrence.html"
},
{
"type": "theorem",
"title": "Markov chains: recurrent iff infinite visits",
"description": "State i is recurrent iff we will visit it infinitely many times with probability 1.",
"uci": "/probability/markov-chains/rec-infinite-visits",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/rec-infinite-visits.html"
},
{
"type": "theorem",
"title": "Chapman-Kolmogorov equation",
"description": "Let P be the transition matrix of a markov chain. Then the probability of being in state j after t steps starting from state i is (P^t)[i,j].",
"uci": "/probability/markov-chains/chap-kol-eqn",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/chap-kol-eqn.html"
},
{
"type": "theoremdef",
"title": "Markov chains: accessibility and state classes",
"description": "Two states i and j in a markov chain are said to communicate iff P^n(i, j) > 0 and P^n(j, i) > 0. Communication is an equivalence relation, and the equivalence classes are called state classes.",
"keywords": [
"accessibility",
"accessible",
"communicate",
"communicable",
"irreducible",
"irreducibility"
],
"uci": "/probability/markov-chains/state-classes",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/state-classes.html"
},
{
"type": "theorem",
"title": "Markov chains: long run proportion is inverse of time to reenter",
"description": "Let m_j be the expected time to return to state j starting from state j. Let i be a state that communicates with j. Then the long run proportion of state j starting from i is 1/m_j.",
"uci": "/probability/markov-chains/long-run-prop-vs-time-to-reenter",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/long-run-prop-vs-time-to-reenter.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Markov chains: recurrent state to acessible state",
"description": "If i is a recurrent state of a markov chain and state j is accessible from state i, then the marov chain will eventually reach j from i.",
"uci": "/probability/markov-chains/rec-to-other",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/rec-to-other.html",
"status": "incomplete"
},
{
"type": "def",
"title": "Markov chains: positive recurrence",
"description": "A recurrent state is called positive recurrent if the expected time to return to that state is finite.",
"uci": "/probability/markov-chains/positive-rec",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/positive-rec.html"
},
{
"type": "theorem",
"title": "Markov chains: positive recurrence is a class property",
"description": "If a state is positive recurrent, then all states in its class are positive recurrent.",
"uci": "/probability/markov-chains/pos-rec-class",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/pos-rec-class.html"
},
{
"type": "theorem",
"title": "Markov chains: finite sink is positive recurrent",
"description": "If no other state class is accessible from a finite state class J, then J is positive recurrent.",
"uci": "/probability/markov-chains/finite-sink-is-pos-rec",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/finite-sink-is-pos-rec.html"
},
{
"type": "def",
"title": "Median of a random variable",
"description": "For a real-valued random variable X, m is a median iff P(X \u2264 m) \u2265 1/2 and P(X \u2265 m) \u2265 1/2.",
"uci": "/probability/rand-vars/median/median",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/median/median.html"
},
{
"type": "theorem",
"title": "Random variables: multiple medians",
"description": "Let m1 and m2 be medians of a random variable X such that m1 < m2. Then P[X\u2264m1] = 1/2, P[m1<X<m2] = 0, and P[X\u2265m2] = 1/2.",
"uci": "/probability/rand-vars/median/multi",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/median/multi.html"
},
{
"type": "def",
"title": "Expected value of a random variable",
"description": "The expected value of a random variable is its (Lebesgue) integral over the sample space.",
"uci": "/probability/rand-vars/expected-value",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/expected-value.html"
},
{
"type": "theorem",
"title": "Probability: limit of CDF",
"description": "Let F be a CDF of a real random variable. Then F(-\u221e) = 0 and F(\u221e) = 1.",
"uci": "/probability/rand-vars/cdf-limit",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/cdf-limit.html"
},
{
"type": "def",
"title": "Conditioning over random variable",
"description": "Let X be a random variable and A be an event. Let g(x) = P(A|X=x). Then P(A|X) is defined as g(X).",
"uci": "/probability/rand-vars/cond-over-rand-var",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/cond-over-rand-var.html"
},
{
"type": "theorem",
"title": "Distribution of sum of random variables",
"uci": "/probability/rand-vars/distr-of-sum-of-rand-vars",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/distr-of-sum-of-rand-vars.html",
"status": "incomplete"
},
{
"type": "def",
"title": "Conditional expectation",
"uci": "/probability/rand-vars/cond-expec",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/cond-expec.html"
},
{
"type": "theorem",
"title": "Law of total probability: E(Y) = E(E(Y|X))",
"uci": "/probability/rand-vars/ltp3",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/ltp3.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Law of total probability: P(A) = E(P(A|X))",
"uci": "/probability/rand-vars/ltp2",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/ltp2.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Law of total probability: decomposing expectation over countable events",
"uci": "/probability/rand-vars/ltp1",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/ltp1.html"
},
{
"type": "theoremdef",
"title": "Independence of random variables",
"uci": "/probability/rand-vars/rand-var-ind",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/rand-var-ind.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Expectation of product of independent random variables",
"description": "Let X and Y be independent random variables. Then E(XY) = E(X)E(Y).",
"uci": "/probability/rand-vars/indep-prod-expec",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/indep-prod-expec.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "X \u2264 Y \u27f9 E(X) \u2264 E(Y)",
"uci": "/probability/rand-vars/expec-le",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/expec-le.html"
},
{
"type": "def",
"title": "Counting process",
"description": "A counting process is a sequence of random variables that counts the number of events occuring over time.",
"keywords": [
"independent",
"stationary"
],
"uci": "/probability/rand-vars/counting-process",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/counting-process.html"
},
{
"type": "theorem",
"title": "X and Y are independent implies X and f(Y) are independent",
"uci": "/probability/rand-vars/derived-ind",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/derived-ind.html"
},
{
"type": "theorem",
"title": "Linearity of expectation",
"description": "Expectation of sum of random variables is sum of expectation of those random variables.",
"uci": "/probability/rand-vars/linearity-of-expec",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/linearity-of-expec.html"
},
{
"type": "theorem",
"title": "Markov chains: recurrent iff expected number of visits is infinite",
"description": "State i is recurrent iff the expected number of times we visit it is infinite.",
"uci": "/probability/markov-chains/rec-n-visits",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/rec-n-visits.html"
},
{
"type": "theorem",
"title": "Markov chains: recurrence is a class property",
"description": "In a state class, either all states are recurrent or no states are recurrent.",
"uci": "/probability/markov-chains/rec-class",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/rec-class.html"
},
{
"type": "theorem",
"title": "Markov chains: recurrent class is sink",
"description": "If a state class is recurrent, then no other class is accessible from it.",
"uci": "/probability/markov-chains/rec-is-sink",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/rec-is-sink.html"
},
{
"type": "theorem",
"title": "Markov chains: finite sink is recurrent",
"description": "In a markov chain, let I be a state class having a finite number of states. Then I is recurrent iff no other state class is accessible from I.",
"uci": "/probability/markov-chains/finite-sink-is-rec",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/markov-chains/finite-sink-is-rec.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Minimizer of f(z) = E(|X-z|) is median",
"uci": "/probability/rand-vars/median/minimizer",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/median/minimizer.html"
},
{
"type": "theoremdef",
"title": "Variance of a random variable",
"description": "The variance of a random variable X is Var(X) = E((X-E(X))^2).",
"uci": "/probability/rand-vars/variance/variance",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/variance.html"
},
{
"type": "theorem",
"title": "|mean - median| \u2264 stddev",
"uci": "/probability/rand-vars/median/close-to-mean",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/median/close-to-mean.html"
},
{
"type": "def",
"title": "Conditional variance",
"uci": "/probability/rand-vars/variance/cond-var",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/cond-var.html"
},
{
"type": "theoremdef",
"title": "Covariance of 2 random variables",
"description": "Cov(X, Y) = E((X - E(X))(Y - E(Y))).",
"uci": "/probability/rand-vars/variance/covariance",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/covariance.html"
},
{
"type": "theorem",
"title": "Var(Y) = Var(E(Y|X)) + E(Var(Y|X))",
"uci": "/probability/rand-vars/variance/cond-decomp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/cond-decomp.html"
},
{
"type": "theorem",
"title": "Var(aX + b) = a^2 Var(X)",
"keywords": [
"variance",
"affine",
"linear"
],
"uci": "/probability/rand-vars/variance/variance-of-affine",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/variance-of-affine.html"
},
{
"type": "theorem",
"title": "Variance of sum of independent random variables",
"description": "If X_1, X_2, ..., X_n are independent random variables, then Var(X_1 + X_2 + ... + X_n) = Var(X_1) + Var(X_2) + ... + Var(X_n).",
"uci": "/probability/rand-vars/variance/var-of-sum-of-ind",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/var-of-sum-of-ind.html"
},
{
"type": "theorem",
"title": "Linearity of expectation for matrices",
"description": "If A is a matrix and X is a random matrix, then E(AX) = AE(X) and E(XA) = E(X)A.",
"uci": "/probability/rand-vars/linearity-of-expec-for-matrices",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/linearity-of-expec-for-matrices.html"
},
{
"type": "theoremdef",
"title": "Cross-covariance matrix",
"uci": "/probability/rand-vars/variance/cross-covariance-matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/cross-covariance-matrix.html"
},
{
"type": "def",
"title": "Covariance matrix",
"uci": "/probability/rand-vars/variance/covariance-matrix",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/variance/covariance-matrix.html"
},
{
"type": "theorem",
"title": "Cauchy-Schwarz inequality for random variables",
"description": "Let X and Y be two complex-valued random variables. Then |E(XY')|\u00b2 \u2264 E(|X|\u00b2)E(|Y|\u00b2).",
"uci": "/probability/rand-vars/cauchy-schwarz",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/rand-vars/cauchy-schwarz.html"
},
{
"type": "def",
"title": "Bernoulli random variable",
"description": "A random variable which takes at most 2 possible values is called a Bernoulli random variable.",
"uci": "/probability/distrs/bernoulli",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/distrs/bernoulli.html"
},
{
"type": "theorem",
"title": "Markov's bound",
"description": "Let X be a non-negative random variable. Then P(X \u2265 a) \u2264 E(X)/a.",
"uci": "/probability/conc-ineq/markov",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/conc-ineq/markov.html"
},
{
"type": "theorem",
"title": "Cantelli's inequality",
"keywords": [
"one-sided",
"chebyshev"
],
"description": "Let X be a random variable with mean \u03bc and variance \u03c3\u00b2. Then P(X \u2265 \u03bc + t) \u2264 \u03c3\u00b2/(\u03c3\u00b2+t\u00b2).",
"uci": "/probability/conc-ineq/cantelli",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/conc-ineq/cantelli.html"
},
{
"type": "theorem",
"title": "Chebyshev's inequality",
"description": "For a real random variable X, Pr(|X - E(X)| \u2265 a) \u2264 Var(X)/a^2.",
"uci": "/probability/conc-ineq/chebyshev",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/conc-ineq/chebyshev.html"
},
{
"type": "theorem",
"title": "Function with non-negative second derivative and 2 zeros",
"description": "Let f be a function with f''(x) \u2265 0 and f(a) = f(b) = 0. Then for x \u2208 [a, b], f(x) \u2264 0.",
"uci": "/analysis/nonneg-dd-func-with-2-zeros",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/analysis/nonneg-dd-func-with-2-zeros.html",
"status": "incomplete"
},
{
"type": "theoremdef",
"title": "Limit of a function at a point",
"description": "Limit of a function at a point",
"uci": "/analysis/limit",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/analysis/limit.html"
},
{
"type": "theorem",
"title": "Gaussian integral",
"description": "The integral of e^(-x^2) from -\u221e to \u221e is \u221a\u03c0.",
"uci": "/analysis/gaussian-integral",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/analysis/gaussian-integral.html",
"status": "incomplete"
},
{
"type": "theoremdef",
"title": "Normal distribution",
"uci": "/probability/normal-distr/normal-distr",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/normal-distr/normal-distr.html"
},
{
"type": "theorem",
"title": "Sum of independent normal random variables is normal",
"uci": "/probability/normal-distr/distr-of-sum-of-rand-vars",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/normal-distr/distr-of-sum-of-rand-vars.html"
},
{
"type": "def",
"title": "Standard multivariate normal distribution",
"uci": "/probability/normal-distr/std-multivariate",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/normal-distr/std-multivariate.html"
},
{
"type": "theoremdef",
"title": "General multivariate normal distribution",
"uci": "/probability/normal-distr/gen-multivariate",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/normal-distr/gen-multivariate.html"
},
{
"type": "theoremdef",
"title": "Standard normal random vector on vector space",
"uci": "/probability/normal-distr/std-normal-vector-on-vector-space",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/normal-distr/std-normal-vector-on-vector-space.html"
},
{
"type": "def",
"title": "Convex function",
"description": "A function f is convex iff the line segment joining (x, f(x)) and (y, f(y)) lies completely above the function surface.",
"uci": "/analysis/convex-function",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/analysis/convex-function.html"
},
{
"type": "theorem",
"title": "Series expansion for e^x",
"uci": "/analysis/exp-series",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/analysis/exp-series.html",
"status": "incomplete"
},
{
"type": "def",
"title": "Poisson distribution",
"description": "X is poisson distributed with parameter \u03bb iff X is a non-negative integer and P(X = k) = e^(-\u03bb)\u03bb^k/k!.",
"uci": "/probability/distrs/poisson",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/distrs/poisson.html"
},
{
"type": "def",
"title": "Poisson process",
"description": "A poisson process with parameter \u03bb is a counting process with independent and stationary increments such that N(t) ~ Poisson(\u03bbt).",
"uci": "/probability/poisson-process/poisson-process",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/poisson-process/poisson-process.html"
},
{
"type": "theorem",
"title": "Integration bound",
"description": "Bounding a sum using integration.",
"uci": "/bounds/integration-bound",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/integration-bound.html"
},
{
"type": "theorem",
"title": "Bound on log 2",
"description": "ln(1+x) \u2265 2x/(2+x) for x \u2265 0.",
"uci": "/bounds/log-bound-2",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/log-bound-2.html"
},
{
"type": "theorem",
"title": "Bound on log",
"description": "(x-1)/x \u2264 ln(x) \u2264 x-1.",
"uci": "/bounds/log-bound",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/log-bound.html"
},
{
"type": "theorem",
"title": "Approximation algorithm for covering LPs",
"description": "An \u03b1(1 + \u03b5)-approximation algorithm for solving covering LPs, assuming the presence of a (1/\u03b1)-approximation algorithm for a certain optimization problem",
"keywords": [
"eku",
"pst",
"covering-lp",
"approx",
"index-finding"
],
"uci": "/optimization/linear-prog/eku-pst",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/optimization/linear-prog/eku-pst.html"
},
{
"type": "theorem",
"title": "BP: \u03b1(1+\u03b5)-approx solution to density-restricted config LP using \u03b1-approx algorithm for density-restricted knapsack",
"authors": [
"Eklavya Sharma",
"K.V.N. Sreenivas"
],
"uci": "/packing/config-lp/dr-ks-approx",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/dr-ks-approx.html"
},
{
"type": "theorem",
"title": "2D BP: APTAS for config LP",
"uci": "/packing/geometric/2d-config-lp-aptas",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/geometric/2d-config-lp-aptas.html"
},
{
"type": "theorem",
"title": "BP: \u03b1(1+\u03b5)-approx solution to config LP using \u03b1-approx algorithm for knapsack",
"uci": "/packing/config-lp/ks-approx",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/config-lp/ks-approx.html"
},
{
"type": "theorem",
"title": "1BP: FPTAS for config LP",
"uci": "/packing/1d/fptas-for-config-lp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/fptas-for-config-lp.html"
},
{
"type": "theorem",
"title": "Sum of ceilings",
"description": "\u2211\u2308a\u1d62\u2309 \u2264 \u2308\u2211a\u1d62\u2309 + (n-1).",
"uci": "/bounds/sum-of-ceil",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/sum-of-ceil.html"
},
{
"type": "theorem",
"title": "Simple bound on harmonic sum",
"description": "ln(n) + 1/n \u2264 H(n) \u2264 ln(n) + 1",
"uci": "/bounds/simple-harmonic-bound",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/simple-harmonic-bound.html"
},
{
"type": "theorem",
"title": "Stirling's approximation",
"description": "Upper and lower bounds for factorial.",
"uci": "/bounds/stirlings-approx",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/stirlings-approx.html",
"status": "incomplete"
},
{
"type": "theorem",
"title": "Bound on harmonic sum",
"description": "H(n) = ln n + \ud835\udefe + [0, 1/n].",
"uci": "/bounds/harmonic-bound",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/harmonic-bound.html"
},
{
"type": "theorem",
"title": "Harmonic bound for fraction",
"description": "H(a+b-1) - H(b-1) \u2264 a/b \u2264 H(b) - H(b-a)",
"uci": "/bounds/harmonic-bound-for-fraction",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/harmonic-bound-for-fraction.html"
},
{
"type": "theorem",
"title": "Bound on exponential",
"description": "e^x \u2265 1+x",
"uci": "/bounds/exp-bound",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/exp-bound.html"
},
{
"type": "theorem",
"title": "Chernoff bound",
"description": "Chernoff bound gives concentration result for the sum of independent bernouilli random variables.",
"uci": "/probability/conc-ineq/chernoff",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/probability/conc-ineq/chernoff.html"
},
{
"type": "theorem",
"title": "Bounds on (1+x)^a for 0 \u2264 a \u2264 1",
"uci": "/bounds/power-bound",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/power-bound.html"
},
{
"type": "theorem",
"title": "Bound on k extreme values",
"description": "Let s be the sum of n values. The sum of the smallest k values is at most sk/n.",
"uci": "/bounds/k-extreme-sum",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/k-extreme-sum.html"
},
{
"type": "theoremdef",
"title": "1BP: harmonic grouping",
"uci": "/packing/1d/harmonic-grouping",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/harmonic-grouping.html"
},
{
"type": "theorem",
"title": "1BP: Karmarkar-Karp algorithm",
"description": "The Karmarkar-Karp algorithm is an algorithm for 1BP that achieves an additive approximation of O(log(I)^2).",
"uci": "/packing/1d/karmarkar-karp",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/karmarkar-karp.html",
"status": "broken"
},
{
"type": "theorem",
"title": "Bound on binomial coefficient",
"description": "(n/k)^k \u2264 C(n,k) \u2264 (ne/k)^k",
"uci": "/bounds/binomial-bound",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/bounds/binomial-bound.html"
},
{
"type": "theorem",
"title": "Floor and ceil of fraction",
"description": "Let a and b be integers. Then ceil(a/b) = floor((a-1)/b) + 1. Equivalently, floor(a/b) = ceil((a+1)/b) - 1.",
"uci": "/misc/floor-ceil/fraction",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/floor-ceil/fraction.html"
},
{
"type": "theorem",
"title": "Negation of floor",
"description": "floor(-x) = -ceil(x)",
"uci": "/misc/floor-ceil/neg",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/floor-ceil/neg.html"
},
{
"type": "theorem",
"title": "Floor and ceil of log",
"description": "floor(log_b(a)) = ceil(log_b(a+1)) - 1 and ceil(log_b(a)) = floor(log_b(a-1)) + 1.",
"uci": "/misc/floor-ceil/log",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/floor-ceil/log.html"
},
{
"type": "theorem",
"title": "Exponentiation of log of floor and ceil",
"description": "(a+1)/b \u2264 b^floor(log_b(a)) \u2264 a",
"uci": "/misc/floor-ceil/rounded-power",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/floor-ceil/rounded-power.html"
},
{
"type": "def",
"title": "Dual-feasible function",
"description": "A function f from (0, 1] to (0, 1] is a dual-feasible function (DFF) iff for every vector x \u2208 (0, 1]^*, sum(x) \u2264 1 implies sum(f(x)) \u2264 1.",
"uci": "/misc/dual-feasible-func",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/dual-feasible-func.html"
},
{
"type": "theorem",
"title": "1BP: config LP's dual gives a DFF",
"uci": "/packing/1d/config-lp-dual-gives-dff",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/packing/1d/config-lp-dual-gives-dff.html"
},
{
"type": "theorem",
"title": "Min-weight gap interval",
"description": "Let X be a set of vectors, each with a weight. There is a polynomial-time algorithm to find a non-negligible interval such that the weight of vectors with a component in that interval is small.",
"uci": "/misc/min-weight-gap",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/min-weight-gap.html"
},
{
"type": "theoremdef",
"title": "Submodular function",
"description": "A function is submodular iff its marginal decreases with the size of the set.",
"uci": "/misc/submodular-func",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/submodular-func.html"
},
{
"type": "theorem",
"title": "Matroid: rank is submodular",
"uci": "/matroids/rank-is-submodular",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/rank-is-submodular.html"
},
{
"type": "theorem",
"title": "Matroid: restricted rank is submodular",
"uci": "/matroids/restricted-rank-is-submodular",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/restricted-rank-is-submodular.html"
},
{
"type": "theorem",
"title": "Sum of submodular functions is submodular",
"uci": "/misc/sum-of-submodular-funcs-is-submodular",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/misc/sum-of-submodular-funcs-is-submodular.html"
},
{
"type": "theorem",
"title": "Matroid: weighted rank is submodular",
"description": "The weighted rank of X is the weight of the max-weight basis of X. The weighted rank function is submodular.",
"uci": "/matroids/weights/weighted-rank-is-submodular",
"url": "https://sharmaeklavya2.github.io/theoremdep/nodes/matroids/weights/weighted-rank-is-submodular.html"
}
]
}